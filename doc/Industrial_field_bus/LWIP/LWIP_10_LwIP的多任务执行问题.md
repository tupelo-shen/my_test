[TOC]

最常见的LwIP问题源是在LwIP代码中使用多个可执行上下文。

LwIP可以工作在裸机程序中，也可以工作在操作系统OS下。下面以此为分析点，进行分析：

# 1 裸机程序

在大循环模式下，只有基于回调的API能够使用。用户有两种可能保证LwIP中一次只有一个执行上下文在运行：

* 1) 在中断上下文中直接调用`netif->input`，将接收的以太网数据包传递给LwIP协议栈。这意味着，所有的LwIP回调函数都是在中断上下文中被调用，这可能对应用程序造成深层次的问题：中断处理程序长时间被阻塞，尤其是多个执行上下文的时候。当应用程序想要调用LwIP协议栈时，只需要在调用期间禁止中断即可。如果还涉及到定时器中断，那么还需要添加锁，保护代码不被定时器中断打断（当然，前提是这些锁是可以嵌套的）。

* 2) 在一个主循环中运行LwIP。代码示例可以参考：[Mainloop mode ("NO_SYS")](https://www.nongnu.org/lwip/2_0_x/group__lwip__nosys.html)。这种情况下，LwIP只在主循环中调用。以太网IRQ信号的中断处理例程把接收的数据包存到一个队列中，这个队列也是在主循环中被轮询处理。而且，确保LwIP绝对不会被中断调用，比如，SPI相关的中断处理程序直接调用udp_send()或者tcp_write()，发送数据，这是绝对不允许的！

# 2 OS模式

在带有操作系统的时候，基于回调的API和阻塞式（也称为`Sequential-style`）的API都能使用。阻塞式API是为线程thread设计的，而不是被TCPIP线程调用。这里无需过多考虑。但是，基于回调的API只能被TCPIP线程调用。从其它线程或者中断上下文中调用这些回调API函数是常见的错误。以太网数据包接收到后，通过发送消息给TCPIP线程，以正确的方式将接收中的数据包传递给TCPIP线程，这是在`tcpip_input()`中实现的。再一次强调，绝对不能从中断中调用LwIP协议栈，比如上面的SPI中断中发送网络数据包等。

* 1) 可以使用`tcpip_callback()`，从TCPIP线程中调用回调，从这儿调用任何回调函数都是安全的。

* 2) 使用`LWIP_TCPIP_CORE_LOCKING`。当使用LwIP核心锁的时候，任何回调函数都可以被调用。参见`LOCK_TCPIP_CORE()`和`UNLOCK_TCPIP_CORE()`。这些宏不能在中断上下文中使用！注意，操作系统必须正确处理优先级反转的问题。

<h1 id="0">0 目录</h1>

* [1 内存相关](#1)
* [2 数据类型](#2)
* [3 函数](#3)
* [4 面向对象](#4)
* [5 编程](#5)


<h1 id="1">1 内存相关</h1>

<h2 id="1.1">1.1 new、delete、malloc、free关系</h2>

1. 属性
    
    malloc与free是C++/C语言标准库的函数，new/delete是C++的运算符（即关键字）。

2. 参数
    
    使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出内存的大小。

3. 返回类型
    
    new申请内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。 而malloc内存分配成功则是返回 *void \** ，需要通过强制类型转换将 *void \**  指针转换成我们需要的类型。

4. 分配失败
    
    new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。

5. 自定义类型
    
    *new* 会先调用 *operator new* 函数，申请足够的内存（通常底层使用 *malloc* 实现）。 然后调用类型的构造函数， 初始化成员变量， 最后返回自定义类型指针。*delete*先调用析构函数，然后调用 *operator delete* 函数释放内存（通常底层使用 *free*实现）。

    *malloc/free*是库函数，只能动态地申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

6. 重载    
    
    C++允许重载 *new/delete* 操作符，特别的，*placement new*的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，*new*在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而 *malloc*不允许重载

7. 内存区域

    *new*操作符从自由存储区（free store）上为对象动态分配内存空间，而 *malloc*函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用*malloc*从堆上分配内存， 使用*free*释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。

> PS: 在C++中，内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区；
> 
> 在C中，C内存区分为堆、栈、全局/静态存储区、常量存储区；
> 
> new缺省的实现方式本质上是通过malloc的，这个时候，C++的自由存储区的概念和C的堆的概念是没有区别的， 但是, 如果我们通过重载operator new的方式把内存分配在一些全局变量上，那么这些内存就不属于堆区了，而是在data segment。也就是说，C++的自由存储区可以包括堆区，也可以包括其他区域。

<h2 id="1.2">1.2 为什么new/delete、new[]/delete[]要配对使用？</h2>
   
因为它们在调用构造函数和析构函数的时候不同。带有[]的表达式因为需要多分配4个字节，因为析构时需要知道对象的个数。所以它们的执行方式是不同的，必须配套使用。

对于内建简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]不能互用。delete[]删除一个数组，delete删除一个指针。简单来说，用new分配的内存用delete删除；用new[]分配的内存用delete[]删除。delete[]会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用delete时没用括号，delete就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。

<h2 id="1.3">1.3 如何将程序跳转到指定内存地址？</h2>
    
要对绝对地址0x100000赋值，我们可以用 *(unsigned int\*)0x100000 = 1234*;那么要是想让程序跳转到绝对地址是 *0x100000*去执行，应该怎么做？

    *((void (*)( ))0x100000 ) ();

首先要将0x100000强制转换成函数指针,即:

    (void (*)())0x100000

然后再调用它:

    *((void (*)())0x100000)();

用typedef可以看得更直观些:
    
    typedef void(*)() voidFuncPtr;
    *((voidFuncPtr)0x100000)();


<h2 id="1.4">1.4 描述内存分配方式以及他们的区别</h2>

1. 堆
    
    亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。

2. 栈
    
    在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈由于是编译器自动管理的，所以栈内的对象不会存在内存泄露问题。

3. 常量区
    
    存放常量字符串，程序结束后由系统释放

4. 静态变量区
    
    内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。

<h2 id="1.5">1.5 栈内存与文字常量区</h2>

代码如下：

    char str1[] = "abc";
    char str2[] = "abc";

    const char str3[] = "abc";
    const char str4[] = "abc";

    const char *str5 = "abc";
    const char *str6 = "abc";

    char *str7 = "abc";
    char *str8 = "abc";

    cout << ( str1 == str2 ) << endl;//0  分别指向各自的栈内存
    cout << ( str3 == str4 ) << endl;//0  分别指向各自的栈内存
    cout << ( str5 == str6 ) << endl;//1指向文字常量区地址相同
    cout << ( str7 == str8 ) << endl;//1指向文字常量区地址相同

结果是：*0 0 1 1*

解答：*str1,str2,str3,str4*是数组变量，它们有各自的内存空间；而 *str5,str6,str7,str8*是指针，它们指向相同的常量区域。


---

<h1 id="2">2 数据类型</h1>

<h2 id="2.1">2.1 结构和联合有何区别？</h2>

1. 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。 

2. 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的


<h2 id="2.2">2.2 请说出const与#define 相比，有何优点？</h2>

const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。

1. const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。

2. 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。

<h2 id="2.2">2.2 简述数组与指针的区别？</h2>

C/C++程序中，指针和数组在不少地方可以相互替换着用，让人产生一种错觉，以为两者是等价的。

数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。

指针可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。

下面以字符串为例比较指针与数组的特性。

1. 修改内容上的差别
    
    示例1中，字符数组a的容量是6个字符，其内容为 *hello\0*。a的内容可以改变，如 *a[0] = ‘X’*。指针p指向常量字符串“world”（位于静态存储区，内容为 *world\0*），常量字符串的内容是不可以被修改的。从语法上看，编译器并不觉得语句 *p[0]= ‘X’*有什么不妥，但是该语句企图修改常量字符串的内容而导致运行错误。

        char a[] = “hello”;
        a[0] = 'X';
        char *p = 'world';      // 注意p 指向常量字符串
        p[0] = 'X';             // 编译器不能发现该错误，运行时错误

2. 内容复制与比较
    
    不能对数组名进行直接复制与比较。示例2中，若想把数组a的内容复制给数组b，不能用语句 b = a ，否则将产生编译错误。应该用标准库函数strcpy进行复制。同理，比较b和a的内容是否相同，不能用if(b==a) 来判断，应该用标准库函数strcmp进行比较。

    语句p = a 并不能把a的内容复制指针p，而是把a的地址赋给了p。要想复制a的内容，可以先用库函数malloc为p申请一块容量为strlen(a)+1个字符的内存，再用strcpy进行字符串复制。同理，语句if(p==a) 比较的不是内容而是地址，应该用库函数strcmp来比较。
   
        // 数组…
        char a[] = "hello";
        char b[10];
        strcpy(b, a);           // 不能用   b = a;
        if(strcmp(b, a) == 0)   // 不能用  if (b == a)

3. 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。

        char a[] = "hello world";
        char *p = a;
        cout<< sizeof(a) << endl; // 12 字节
        cout<< sizeof(p) << endl; // 4 字节
        // 计算数组和指针的内存容量
        void Func(char a[100])
        {
            cout<< sizeof(a) << endl; // 4 字节而不是100 字节
        }

<h2 id="2.3">2.3 int id[sizeof(unsigned long)];这个对吗？为什么？</h2>

正确 这个 sizeof是编译时运算符，编译时就确定了  ,可以看成和机器有关的常量。


---

<h1 id="3">3 函数</h1>

<h2 id="3.1">3.1 函数传递参数时，指针和引用的区别</h2>

指针传递参数本质上还是 **值传递** 方式，它所传递的是一个地址值。值传递的过程中，被调函数的形参作为局部变量处理，即在函数分配的栈中分配内存空间，存放主调函数传递进来的实参值，从而形成了一个实参的副本。值传递的特点就是，被调函数对形参的处理都是对实参的一份拷贝进行处理，不会影响主调函数中实参的值。

引用传递参数过程中，被调函数的形参也作为局部变量在栈中开辟了存储空间。但是这时存放的是主调函数的实参的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响到主调函数中的实参变量。

引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。

从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。

**总结**

1. 相同点：
    
    都是地址的概念

2. 不同点：
    
    1. 指针是一个实体（替身）；引用只是一个别名（本体的另一个名字）

    2. 引用只能在定义时被初始化一次，之后不可改变，即“从一而终”；指针可以修改，即“见异思迁”；

    3. 引用不能为空（有本体，才有别名）；指针可以为空；

    4. sizeof 引用，得到的是所指向变量的大小；sizeof 指针，得到的是指针的大小；

    5. 指针 ++，是指指针的地址自增；引用++是指所指变量自增；

    6. 引用是类型安全的，引用过程会进行类型检查；指针不会进行安全检查；

<h2 id="3.2">3.2 在什么时候需要"常引用"</h2>

如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式：const 类型标识符 &引用名=目标变量名；

例1

    int a ;
    const int &ra=a;
    ra=1;               //错误
    a=1;                //正确

例2

    string foo( );
    void bar(string & s);

那么下面的表达式将是非法的：

    bar(foo( ));
    bar("hello world");

原因在于foo( )和"hello world"串都会产生一个临时对象，而在C++中，这些临时对象都是const类型的（也就是说，都是右值类型，转变为 *non-const* 引用是不可以的）。因此上面的表达式就是试图将一个const类型的对象转换为非const类型，这是非法的。引用型参数应该在能被定义为const的情况下，尽量定义为const 。这儿的代码如果想要不报错，*void bar(string & s);* 修改为 *void bar(const string & s);* 即可。

<h2 id="3.3">3.3 将"引用"作为函数返回值类型的格式、好处和需要遵守的规则?</h2>

1. 语法
    
        type-specifier & funtion（parameter-list） {// function body}

2. 优势
    
    在内存中不产生返回值的副本；（注意：正是因为这一点，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存周期的结束，相应的引用也会失效，产生运行时错误。

3. 注意事项
    
    (1). 不能返回局部变量的副本。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成了"无所指"的引用，程序会进入未知状态

    (2). 不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。

    (3). 可以返回类成员的引用，但最好是const。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。

    (4). 流操作符重载返回值申明为“引用”的作用：

    流操作符<<和>>，这两个操作符常常希望被连续使用，例如：cout << "hello" << endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个<<操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用<<操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。 

    赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。

查看下面代码：

    #include<iostream.h>

    int error = -1;
    int vals[10];

    int& put(int n)
    {
        if ( n >= 0 && n <= 9)
            return vals[n];
        else
        {
            cout << "subscript error";
            return error;
        }
    }
    int main(void)
    {
        // test the put() function
        cout << vals[0] << endl; 
        cout << vals[9] << endl; 
        put(0)=10;                  //以put(0)函数值作为左值，等价于vals[0]=10; 
        put(9)=20;                  //以put(9)函数值作为左值，等价于vals[9]=20; 
        cout << vals[0] << endl; 
        cout << vals[9] << endl;  
        
        return 0;
    }

<h2 id="3.4">3.4 int (*s[10])(int) 表示的是什么？</h2>

*int (\*s[10])(int)* 函数指针数组，每个指针指向一个int func(int param)的函数。


<h2 id="3.5">3.5 复杂声明</h2>

    void *(*(* fp1)(int))[10];
    float (*(* fp2)(int,int,int))(int);
    int (*(* fp3)())[10]();

分别表示什么意思？

1. fp1是一个指针，指向一个函数，这个函数的参数为int型，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个void*型指针。
2. 
---

<h1 id="4">4 面向对象</h1>

<h2 id="4.1">4.1 C++有哪些性质（面向对象特点）</h2>

封装，继承和多态。

<h2 id="4.2">4.2 子类析构时要调用父类的析构函数吗？</h2>

析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了。定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数。

<h2 id="4.3">4.3 多态，虚函数，纯虚函数</h2>

1. 多态
    
    是对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面：在程序运行时的多态性通过继承和虚函数来体现；在程序编译时多态性体现在函数和运算符的重载上；

2. 虚函数
    
    在基类中冠以关键字 *virtual* 的成员函数。 它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。

3. 纯虚函数的作用
    
    在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在 纯虚函数不具备函数的功能， 一般不能直接被调用。

从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（abstract class）。

抽象类中不仅包括纯虚函数，也可包括虚函数。抽象类必须用作派生其他类的基类，而不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。

<h2 id="4.4">4.4 重载（overload）和重写（override）的区别</h2>

常考的题目。从定义上来说：

1. 重载：
    
    是指允许存在多个同名的函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）

2. 重写：
    
    是指子类重新定义父类虚函数的方法。

从实现原理上说：

1. 重载：

    编译器根据函数不同的参数表，对同名函数的名称作修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。比如，有2个同名函数：
        
        function func(p: integer):integer;
        function func(p: string):integer;
    
    那么，编译器做过修饰后的函数名称可能是这样的：

        int_func 和 str_func

    对于这两个函数的调用，在编译期间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了，因此，重载是在编译期间的多态。

2. 重写：
    
    与程序的运行时多态相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。

<h2 id="4.5">4.5 有哪几种情况只能用intialization list而不能用assignment？</h2>

当类中含有const、reference成员变量时；基类的构造函数需要初始化列表。

<h2 id="4.6">4.6 C++是不是类型安全的？</h2>

不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。

<h2 id="4.7">4.7 main 函数执行以前，还会执行什么代码？</h2>

答案：全局对象的构造函数会在main 函数之前执行。

---

<h1 id="5">5 编程题</h1>

<h2 id="5.1">5.1 获取一个整数中的bit位为1的个数（微软）</h2>

    int func(x) 
    { 
        int countx = 0; 
        while(x) 
        { 
            countx ++; 
            x = x & (x-1); 
        } 
        return countx; 
    } 

假定 *x = 9999*。 答案：*8*

<h2 id="5.2">5.2 左值引用作为函数的返回值</h2>

    int  a=4;
    int& f( int x )
    {    
        a = a+x;
        return a;
    }
    int main(void)
    {    
        int   t=5;
        cout << f(t) << endl;  // -> a = 9
        f(t) = 20;             // -> a = 20
        cout << f(t) << endl;  // t = 5,a = 20 -> a = 25
        t = f(t);              // -> a = 30 t = 30
        cout << f(t) << endl;  // -> a = 60
    }

<h2 id="5.3">5.3 分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句</h2>

1. bool 
    
    if (!a) 或 if (a)

2. int 
    
    if (0 == a)

3. float 
    
    const EXPRESSION EXP = 0.000001 
    if ( a < EXP && a >-EXP)

4. pointer 
    
    if ( a != NULL) or if(a == NULL)


<h1 id="2">2 网络</h1>

<h1 id="2.1">2.1 TCP模型，状态迁移</h1>

TCP/IP四层网络模型：

1. **链路层（数据链路层和物理层）**：包括操作系统中的设备驱动程序、计算机中对应的网络接口卡
2. **网络层**：处理分组在网络中的活动，比如分组的选路
3. **运输层**：主要为两台主机上的应用提供端到端的通信
4. **应用层**：负责处理特定的应用程序细节

假设在一个局域网（LAN）如以太网中有两台主机，二者运行FTP协议：



# 一级交叉开关地址路由

龙芯 3A 的路由主要通过系统的两级交叉开关实现。一级交叉开关地址路由一级交叉开关可以对每个 Master端口接收到的请求进行路由配置，每个Master端口都拥有 8个地址窗口，可以完成 8 个地址窗口的目标路由选择。每个地址窗口由 BASE、MASK和 MMAP三个 64 位寄存器组成，BASE以K字节对齐；MASK采用类似网络掩码高位为1的格式；MMAP的低三位表示对应目标Slave端口的编号，MMAP[4]表示允许取指，MMAP [5]表示允许块读，MMAP [7]表示窗口使能。

窗口命中公式:` (IN_ADDR & MASK) == BASE`

由于龙芯3号缺省采用固定路由，在上电启动时，配置窗口都处于关闭状态，使用时

需要系统软件对其进行使能配置。一级交叉开关地址窗口寄存器表参见龙芯3A用户手册表2-5。

下面分析地址路由过程，假设地址从CORE0的Master端口进入，那么有8个地址窗口进行选择，这时候会和8个地址窗口的`CORE0_MASK0 ~ CORE0_MASK7`进行与运算，若与运算结果等于`CORE0_BASEi`且`CORE_MMAPi` 的第7位使能窗口，则说明选择第i个窗口进行路由，然后再由MMAP的低三位选择Slave端口。

# 二级交叉开关地址路由

#### 二级交叉开关的概念

二级 XBAR中有CPU地址空间（包括 HT空间）、DDR2地址空间、以及 PCI地址空间共三个IP相关的地址空间。地址窗口是供CPU和PCI-DMA两个具有Master功能的IP 进行路由选择和地址转换而设置的。CPU 和 PCI-DMA 两者都拥有 8 个地址窗口（一级XBAR中每个CORE做主设备拥有8个地址窗口，而二级XBAR中连接四个二级Cache的四个主设备共用8个地址窗口），可以完成目标地址空间的选择以及从源地址空间到目标地址空间的转换。每个地址窗口由 BASE、MASK和 MMAP三个 64位寄存器组成，BASE 以 K字节对齐，MASK采用类似网络掩码高位为 1的格式，MMAP的低三位是路由选择。MMAP[4]表示允许取指，MMAP[5]表示允许块读，MMAP[7]表示窗口使能，MMAP低三位用于描述具体的物理设备，如下所示。两个DDR2的标号分别为0与1，PCI/Local IO编号为 2，配置寄存器模块连接在端口3上）：

| MMAP低三位 | 默认值 |
| ---------- | ------ |
| 0 | 0号DDR2/3控制器 |
| 1 | 1号DDR2/3控制器 |
| 2 | 低速I/O（PCI，LPC）|
| 3 | 配置寄存器 |

#### 与一级交叉开关的区别

二级 XBAR 的地址配置与一级XBAR的地址配置相比增加了地址转换的功能。相比之下，一级XBAR的窗口配置不能对 Cache一致性的请求进行地址转换，否则在二级 Cache 处的地址会与处理器一级 Cache处的地址不一致，导致 Cache一致性的维护错误。

通俗的讲，为了维护L1级Cache的一致性，CPU真正想要访问的物理设备上的地址在二级XBAR处进行地址路由。在一级XBAR处只进行数据的缓存功能，所以，一级XBAR处一般情况下也不需要进行配置，由龙芯给出固定设置。

#### 二级XBAR处的地址转换

窗口命中公式: `(IN_ADDR & MASK) == BASE`
新地址换算公式: `OUT_ADDR = (IN_ADDR & ~MASK) | {MMAP[63:10],10’h0}`

#### 虚拟地址到物理地址的访问过程

根据上面的公式，可知，如果CPU给出的程序地址或者虚拟地址，经过TLB转换得到的物理地址（包含不需要TLB映射的kseg0和kseg1段对应的物理地址），想要到达真正的物理设备，需要经过二级XBAR的地址路由。具体的路由规则根据上面的公式给出。如果输入的物理地址与MASK寄存器的内容进行按位与操作之后，等于BASE寄存器的值，则匹配。然后，再看MMAP寄存器的低3位，查看指定的物理设备，然后访问具体的物理设备地址。

# 内存INTERLEAVE实现原理

指数据在多个内存控制器之间交错存储固定大小的地址空间。举个栗子：龙芯3A有两个内存控制器，那么假定经过窗口配置后将0~8K存储在MC0中，8K~16K存储在MC1中，16K~24K存储在MC0中，24K~32K存储在MC1中。因此可以看出8K的偶数倍数据放在MC0中，8K的奇数倍数据存储在MC1中。空间大小可自己配置，如下是我的板子上的2级XBAR配置:

<img src="https://raw.githubusercontent.com/tupelo-shen/my_test/master/doc/linux/mips-architecture/others/images/mips_extra_episode_3_1.PNG">

上图是二级XBAR CPU的8个地址窗口三组寄存器情况。

1. 0x900000003ff00000 ~ 0x900000003ff00038是CPU_WIN0_BASE ~ CPU_WIN7_BASE；
2. 0x900000003ff00040 ~ 0x900000003ff00078是CPU_WIN0_MASK ~ CPU_WIN7_MASK；
3. 0x900000003ff00080 ~ 0x900000003ff000b8是CPU_WIN0_MMAP ~ CPU_WIN7_MMAP。

可以看出8个MMAP的第7位都是1，也即窗口使能。看`0x900000003ff00050 ~ 0x900000003ff00078`的值，MASK一般都是高位全1，低位全0，这里比较奇怪的是如`0x900000003ff00050`值`ffffffff f0010000`。并不是高位全1，低位全0。这样的值会导致什么情况呢？下面分析。

以CPU_WIN2举例分析，前面说过地址命中公式：`(IN_ADDR & MASK) == BASE`，那么`IN_ADDR & 0xffffffff f0010000 == 0x00000000 00000000`。那么IN_ADDR 地址格式如下：

    0x00000000 0**(***0)****        # 括号内为16进制展开为2进制，其余都为16进制字符
                                    # *号表示0/1都可

可以看出现在命中在CPU_WIN2中的地址范围是（高32bit全为0，忽略高32bit）：

    0000 0000 0000 0000 0000 0000 0000 0000 ~ 0000 1111 1111 1110 1111 1111 1111 1111

当中间0的左边为全0，右边任意的0~64K地址命中到窗口2中。按照地址转换公式，其转换后的OUT_ADDR：`0000 0000 0**(***0) ****`，再看MMAP低3位，选择了MC0，即映射到MC0中。同样，128K~192K也映射到MC0中。按照上述运算过程，64K~128K的地址命中窗口3，MMAP第三位选择了MC1，映射到MC1中，同样，192K~256K也映射到MC1中。最终，地址空间低256M中64K的偶数倍地址映射到了MC0的偶数倍64K中，有128M，按照上述的计算过程，CPU_WIN3将低256M的奇数倍64K映射到MC1上的偶数倍64K中，有128M。128M的计算过程是：`(2^11) * (2^16) = 2^27 = 128M` 。11是中间0左边的可0可1位数，16是中间0右边的可0可1的位数。

对于CPU_WIN4： 按照地址命中公式和地址转换公式，其`IN_ADDR = 0000 0000 (1***)**(***0) ****`，`OUT_ADDR = 0000 0000 (0***)**(***0) ****`。所以从虚地址`0000 0000 8000 0000 ~ 0000 0000 fff(1110) ffff`的2G空间中的64K的偶数倍（大小为1G）映射到了MC0的偶数倍64K上，同理对于CPU_WIN5， 这段虚拟地址空间上64K的奇数倍映射到了MC1的偶数倍64K上。

对于CPU_WIN6和CPU_WIN7，可以看出他们的MMAP的第16位为1，这会造成什么影响呢？先看CPU_WIN6，求得`IN_ADDR = 0000 0001 (0***)**(***0) ****， OUT_ADDR = 0000 0000 (0***)**(***1) ****`，红色的1是由第16位MMAP的1在地址转换公式中引起的。这样从`0000 0001 0000 0000 ~ 0000 0001 7ffe ffff` 的大约2G的虚拟地址中64K的偶数倍（大小为1G）映射到了MC0的奇数倍64K上。对于CPU_WIN7，其`IN_ADDR = 0000 0001 (0***)**(***1) ****， OUT_ADDR = 0000 0000 (0***)**(***1) ****`，从`0000 0001 0001 0000 ~ 0000 0001 7fff ffff` 的大约2G的虚拟地址中64K的奇数倍（大小为1G）映射到了MC1的奇数倍64K上。

因此，CPU_WIN4~CPU_WIN7就把4G空间内存按照INTERLEAVE分散到MC0和MC1中去了。由此可以看出上述的内存INTERLEAVE实现细节。实现这个功能对系统的平均访问延迟和平均访问带宽都会带来好处。
## 第2.3节  内核对象

在本节中，我们将简要概述内核实现的对象类型，应用程序可以调用它们的实例(也称为*对象objects*)。这些对象的接口构成了内核本身的接口。创建和使用内核服务就是通过创建、操作和组合这些内核对象来实现的:

- **CNodes** 能力节点(参见第3章)，可以存储多个能力，许可线程调用特定对象的方法。每个CNode有固定数量的slots(槽)，且总是2的整数幂，这在CNode创建时确定。Slots可以是空的，也可以包含能力。

- **线程控制块** (TCBs；参见第6章) 表示seL4中的一个线程。线程是已调度的、阻塞的、未阻塞的，等等的执行单元，这取决于应用程序与其他线程的交互。

- **调度上下文** (仅MCS)(SchedulingContexts；参见第6章) 在seL4中表示CPU时间。用户可以从未分配内存中创建调度上下文，初创时调度上下文为空，不代表任何时间。大部分情况下，每个CPU节点都有一个SchedControl能力，它允许用参数填充调度上下文，并与优先级相结合来控制线程对该CPU的访问时间。

- **端点** (参见第4章) 促成了线程之间的消息通信。IPC是同步的：一个线程试图在一个端点上发送或接收数据，会阻塞直到信息可以传递[^1]。这意味着消息传递只会发生在发送方和接收方在端点会合时，从而内核可以通过一次拷贝来传递消息(或无拷贝而仅使用寄存器来传递短消息)。

  端点能力可以限制为仅发送或仅接收。此外，端点还可以拥有授权能力，这允许将另外的能力作为消息的一部分进行发送。

- **回复对象** (仅MCS)(见第4章) 跟踪调度上下文让渡，提供一次性使用的回复能力容器。它们由seL4_Recv()提供。

- **通知对象** (参见第5章) 提供了一个简单的信号机制。一个通知对象是一个机器字大小的标志集合，每个标志类似于一个两值信号量。操作包括发送信号、轮询检查任何标志的信号、阻塞等待任一标志的信号。通知能力可以限制为仅发送或仅接收。

- **虚拟地址空间对象** (参见第7章) 用于为一个或多个线程构造虚拟地址空间(VSpace)。这些对象大部分直接对应硬件设备，因此是架构依赖的。内核还引入了用于跟踪地址空间状态的ASID[^2]池和ASID控制对象。

- **中断对象** (参见第8章) 赋予应用程序接收和应答硬件设备中断的能力。初始时，系统有一个IRQControl能力，它允许创建IRQHandler能力。一个IRQHandler能力管理一个与特定设备关联的特定中断源，并被委托给一个设备驱动程序用以访问中断源。IRQHandler对象允许线程等待并应答单个中断。

- **未分配内存** Untyped Memory(见第2.4节) 是seL4内核内存分配的基础[^3]。未分配内存能力只有一个单一的方法用于创建新的内核对象。如果方法成功了，则调用线程获得新创建对象的访问能力。此外，未分配内存可以分为一组更小的未分配内存对象，以代表其拥有的部分或全部系统内存。我们在下面的小节中将讨论总体上的内存管理。

[^1]: 这里未考虑非阻塞的情况，因为非阻塞不要求必须成功发送或接收。

[^2]: Address Space IDentifier

[^3]: untyped直译为“无类型的”，其相应的操作retype直译为“类型化”或“重新类型化”，与“未分配的”、“分配”、“重新分配”语义是有差别的。但这里还是选择了后者，因为前者拗口且理解起来费劲，学究气太浓；后者更为人熟知，且不影响阅读，包括源代码，即使对于“retyped a new untyped”的情况，也可译成“分配为一个新的未分配对象”。


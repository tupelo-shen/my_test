## 第2.4节  内核内存分配

seL4微内核不会动态地为内核对象分配内存。相反，必须从应用程序控制的内存区域，通过`未分配内存能力`显式地创建对象。也就是，为了创建新对象，应用程序必须要有明确的授权(通过这些未分配内存能力)。对象一旦创建就会消耗固定数量的内存。这些机制可以用于精确控制特定数量物理内存对应用程序的可用性，包括能够强制隔离应用程序或设备之间的物理内存访问。除了硬件专用的以外，内核本身不要求任何的资源限制(虚拟ASIDs的处理利用了固定数量的地址空间，这一限制将在后续的版本中移除[^1])，因此也就避免了很多通过消耗资源实施的拒绝服务攻击。

在系统引导时，`seL4`预先分配内核本身所需的内存，包括代码、数据和堆栈部分(`seL4`是单内核栈操作系统[^2])。然后，它创建一个初始用户线程(使用适当的地址和能力空间)，将所有剩余的内存，以`未分配内存能力`的形式交给初始线程。同时还有一些启动初始线程所需的附加内核对象能力。这些未分配内存区域可以使用`seL4_Untyped_Retype()`方法，进一步分割成多个小的区域或其他内核对象，这些新的对象称为其`子对象`。

用户应用程序对使用`seL4_Untyped_Retype()`创建的对象拥有全部权限，它可以将全部或部分权限委托给它的一个或多个客户程序。

`未分配内存`对象可以表示两种不同的内存：通用内存或设备内存。`通用内存`可以执行内核提供的未分配内存上的任何操作，可以分配作任意类型的对象。`设备内存`指硬件平台保留的设备内存区域，这些对象的使用受到内核的以下限制:

- 设备未分配内存只能重新分配为页帧或其他未分配内存对象。例如，开发者不能从设备内存中创建端点。

- 从设备未分配内存中重新分配的页帧对象不能设置为线程IPC缓冲区，或用于创建ASID池。

子对象的这种`通用内存`或`设备内存`属性，继承自其父对象，开发者不能进行更改。

[^1]: 大概指AArch32上的实现。

[^2]: 与之相对的是多内核栈操作系统，比如Linux，每个线程都有一个内核栈。参阅：[http://www.disy.cse.unsw.edu.au/theses_public/05/mwarton.pdf](http://www.disy.cse.unsw.edu.au/theses_public/05/mwarton.pdf)

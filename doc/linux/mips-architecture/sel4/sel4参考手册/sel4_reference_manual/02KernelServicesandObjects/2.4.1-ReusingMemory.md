### 2.4.1  重用内存

The model described thus far is sufficient for applications to allocate kernel objects, distribute authority among client applications, and obtain various kernel services provided by these objects. This alone is sufficient for a simple static system configuration.

目前所描述的模型足以让应用程序分配内核对象，在客户应用程序之间分配权限，并获得由这些对象提供的各种不同的内核服务。对于简单的静态系统配置来说，这就足够了。

The seL4 kernel also allows Untyped Memory regions to be reused. Reusing a region of memory is allowed only when there are no dangling references (i.e., capabilities) left to the objects inside that memory. The kernel tracks capability derivations, i.e., the children generated by the methods seL4_Untyped_Retype(), seL4_CNode_Mint(), seL4_CNode_Copy(), and seL4_CNode_Mutate().

seL4内核还允许重用未分配内存区域。重用一个内存区域只有在没有悬空引用(即能力)作用于内存中的对象时才可实施。内核跟踪`能力派生`，即，由seL4_Untyped_Retype()、seL4_CNode_Mint()、seL4_CNode_Copy()和seL4_CNode_Mutate ()生成的子对象。

The tree structure so generated is termed the capability derivation tree (CDT).2 For example, when a user creates new kernel objects by retyping untyped memory, the newly created capabilities would be inserted into the CDT as children of the untyped memory capability.

这样生成的树结构称为`能力派生树`(CDT)。例如，当用户通过分配内存创建新的内核对象时，新创建的能力将作为原始未分配内存对象的子能力插入到CDT中。(虽然从概念上讲CDT是独立的数据结构，但实现上它作为CNode对象的一部分而无需另外的内核元数据。)

For each Untyped Memory region, the kernel keeps a watermark recording how much of the region has previously been allocated. Whenever a user requests the kernel to create new objects in an untyped memory region, the kernel will carry out one of two actions: if there are already existing objects allocated in the region, the kernel will allocate the new objects at the current watermark level, and increase the watermark. If all objects previously allocated in the region have been deleted, the kernel will reset the watermark and start allocating new objects from the beginning of the region again.

对于每个未分配内存区域，内核都保持一个`水印`记录以前已经分配的区域。每当用户请求内核在该区域创建新对象时，内核将执行以下两个操作中的一个：如果已经在该区域分配有对象，那么内核将会在当前水平上分配新对象，并增加水印；如果先前在该区域中分配的所有对象都已删除，则内核将重置水印，并重新从区域的开始分配新对象[^1]。

Finally, the seL4_CNode_Revoke() method provided by CNode objects destroys all capabilities derived from the argument capability. Revoking the last capability to a kernel object triggers the destroy operation on the now unreferenced object. This simply cleans up any in-kernel dependencies between it, other objects and the kernel.

最后，由CNode对象提供的seL4_CNode_Revoke()方法将销毁指定能力的所有派生能力。撤销内核对象的最后一个能力将触发现在无人引用对象上的`销毁`操作，这只需清除它与其他对象及内核之间的任何内核依赖项。

By calling seL4_CNode_Revoke() on the original capability to an untyped memory object, the user removes all of the untyped memory object’s children—that is, all capabilities pointing to objects in the untyped memory region. Thus, after this invocation there are no valid references to any object within the untyped region, and the region may be safely retyped and reused.

通过调用原始未分配内存能力的seL4_CNode_Revoke()方法，用户可以删除其所有的子对象 — 即所有指向该内存区域的对象能力。因此，在调用之后未分配区域内已经没有任何对象的有效引用，可以安全地重新分配利用。

[^1]: seL4不支持部分子对象删除后，自动使其内存区域在父对象内可重利用，比如相邻的空闲区合并使用。

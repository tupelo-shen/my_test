### 3.3.2 能力寻址

能力地址存储在一个CPointer(缩写为CPTR)[^1]中，它是一个无符号整数变量。能力根据上面描述的转换算法进行寻址。有两种特殊情况，涉及到对CNode能力的寻址和对能力slots范围的寻址。

回想一下，上面描述的解析算法将遍历CNode能力，只要仍有地址位需要解析翻译。因此，为了寻址一个CNode能力，用户不仅必须提供能力地址，还必须指定能力地址中要解析的最大位数，这称为*深度限制*。

某些调用，如seL4_Untyped_Retype()，要求用户提供能力slots的范围。这是通过提供一个能力基地址(指向范围内第一个slot)和一个指明slots数量的窗口参数(位于第一个slot之后的连续slots)来实现的。

图3.3描述了一个CSpace示例。为了说明这些思想，我们设定了CSpace中10个能力的地址。

![图3.3](3.3.jpg)

图3.3：一个任意CSpace布局

- **Cap A** 第一个CNode有4位的保护值0x0，基数为8位。Cap A驻留在槽0x60中，因此它可以由任何具有0x060xxxxx形式的地址引用(其中xxxxx是任意数字，因为解析过程在前12位之后终止)。为简单起见，我们通常采用地址0x06000000。

- **Cap B** 同样，第一个CNode有4位的保护值0x0，基数为8位。第二个CNode也有一个4位保护值0x0，它是通过L2 CNode Cap到达的，Cap B驻留在索引0x60处。因此，Cap B的地址是0x00F06000。此地址的解析在前24位之后终止。

- **Cap C** 这个能力是通过两个CNodes来寻址的。第三个CNode通过L3 CNode Cap到达，该能力驻留在第二个CNode的索引0x00处。第三个CNode没有保护位，Cap C在索引0x60处，因此它的地址是0x00F00060。这个地址的解析用完了所有的地址位。

- **Caps C-G** 这个范围的能力slots通过提供一个0x00F00060基地址(指包含Cap C的slot)和一个大小为5的窗口来寻址。

- **L2 CNode Cap** 回想一下，要寻址一个CNode能力，用户不仅要提供一个能力地址，还要指定深度限制，也即要解析的最大位数。L2 CNode Cap位于第一个CNode的偏移0x0F处，CNode有4位保护值为0x0，因此它的地址是0x00F00000，深度限制为12位。

- **L3 CNode Cap** 这个能力位于第二个CNode的索引0x00处，它由L2 CNode Cap到达。第二个CNode有一个4位的保护值0x0。因此，该能力的地址是0x00F00000，深度限制为24位。注意，L2和L3 CNode Caps的地址是相同的，但它们的深度限制不同[^2]。

总之，要引用CSpace中的任何能力(或slot)，用户必须提供其地址，同时还必须提供深度限制，除非有默认值。要指定能力slots的范围，用户要提供一个起始地址和窗口大小。

[^1]: 后文尤其是在API参考部分，将用*能力句柄*称谓能力地址，因为这个地址既不是通常意义上的地址或指针值，也不是简单的slots数组索引，而是需要参数约束的解析指示，很像我们熟知的*句柄*含义。CPTR有时独立使用，并用默认的机器字位数作深度限制；有时用index、depth两个参数来表示，其中index就是CPTR。

[^2]: 在API调用时，这个*地址*还需要按照*深度*进行右对齐，即，L3 CNode Cap的*地址*为0x00F000，共24个有效位，恰好是*深度*。同理，L2 CNode Cap的*地址*为0x00F，共12个有效位，与*深度*相同。

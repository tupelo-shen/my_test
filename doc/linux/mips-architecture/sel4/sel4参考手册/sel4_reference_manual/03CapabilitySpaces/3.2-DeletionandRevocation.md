## 第3.2节 删除和撤销

在seL4中，能力可以删除和撤销。这两种方法主要影响能力，但是当删除或撤销导致对象的最后一个引用能力解构时，它们可能会对系统中的对象产生副作用。

如前所述，seL4_CNode_Delete()将从指定的CNode槽中删除一个能力。通常，这就是所发生的一切，但是如果它是对象的最后一个能力，那么这个对象也将被内核销毁，清理所有剩余的内核引用，并为内存重用做准备。

如果要销毁的对象是一个能力容器，即TCB或CNode，销毁过程将在销毁容器之前删除容器中持有的每个能力，如果所包含的能力是相应对象的最后能力，则可能导致进一步的对象销毁。

(递归是有限的，当容器中发现的能力是指向某个CNode的最后一个能力时，该CNode并不被销毁。相反，通过交换该能力和CNode中的第一个能力，使得所发现的CNode变得不可达，因为该能力这时已变成交换出来的能力，从而将被销毁，而原来的CNode能力已在其自身空间内变为自引用。这就打破了递归。

这种方法的结果是，删除一个CSpace根CNode的最后一个能力时不会递归地删除整个CSpace。相反，它删除根CNode，使得树的分支变得不可到达，这可能还包括要删除一些不可到达的CNode能力，以为自引用能力腾出空间。这种方法的实际结果是，如果要避免不可达的CNode, 删除CSpace需要在用户级先删除叶子节点。另外，任何产生的不可到达的CNode，都可以通过撤销覆盖它的未分配内存能力来清理，但是这种方法在用户级构造安排可能更复杂。)

seL4_CNode_Revoke()方法象seL4_CNode_Delete()一样删除指定能力的所有CDT子对象，但保持该能力本身不动。如果任何被撤销的子能力是相应对象的最后能力，则触发相应的对象销毁操作。

注意：seL4_CNode_Revoke()在两种特定情况下可能只能部分完成。第一个是撤销将导致包含调用者线程最后一个引用能力的CNode，或TCB能力本身被删除的情况，在这种情况下，调用者线程会被销毁，而撤销没有完成。第二种情况是，包含要撤销能力的存储区域已由于撤销被删除，在这种情况下，执行撤销的权限会在操作期间被取消，操作将中途停止。这两个场景都可以并应当在构建用户级应用时避免。

注意对于页表和页目录，seL4_CNode_Revoke()不会撤销映射到虚拟地址空间的内存页能力，而只会从地址空间中取消映射。

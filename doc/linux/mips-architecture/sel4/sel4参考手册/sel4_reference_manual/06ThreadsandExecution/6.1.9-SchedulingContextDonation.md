### 6.1.9  调度上下文让渡

除了通过seL4_SchedContext_Bind()和seL4_SchedContext_UnbindObject()显式绑定和解绑调度上下文外，调度上下文还可以通过IPC在线程之间移动。当系统调用seL4_Call()和seL4_NBSendRecv()与被动线程通信时，将隐式地让渡调度上下文。主动线程调用seL4_Call()引用端点并与被动线程会合，主动线程的SC将让渡给被动线程。生成的回复能力确保被动方只是借用SC：当回复消息发送出去因而消费掉回复能力后，SC将返回给主动方。如果回复能力被撤销，且被动方持有SC，则SC也将返还给主动方。但是，如果是在深度调用链中，并且调用链中间的回复能力被撤销，这时被动方不拥有SC，那么该线程将从调用链中移除，SC保留在原来的位置。如果接收者没有提供一个回复对象来跟踪让渡(如使用seL4_Wait()而不是seL4_Recv())，SC让渡将不会发生，但是消息仍将被传递；被动接收方将被设置为不活跃，因为它没有调度上下文。

考虑一个例子，线程A调用线程B，B调用C。如果C持有调度上下文的情况下，B的回复能力被撤销，那么调度上下文将保持在C。但是，A和C之间的调用链依然存在，因此如果C的回复能力被撤销或引用，调度上下文都将返还给A。

seL4_NBSendRecv()也能导致调度上下文让渡。如果操作在非阻塞发送阶段将消息传递到被动线程，则SC也将被让渡给被动线程，并且在接收阶段，发起系统调用的线程在接收端点上成为被动的一方。如果没有生成回复能力，那么不能保证SC会返还，虽然这增加了簿记的复杂性，但为数据流类的体系架构所允许，远程过程调用类系统则不合适。注意，seL4_Call()并不保证调度上下文一定会返还：这是一个固有的信任操作，就像服务器可能永不回复并返回调度上下文。

调度上下文还可以使用seL4_SchedContext_Bind()绑定到通知对象，使用seL4_SchedContext_UnbindObject()取消绑定。如果一个信号被发送到一个通知对象，并且有一个被动线程正阻塞等待它，该线程将接收到绑定的SC。当线程再次阻塞在通知对象时，将返还SC。该特性允许被动服务器使用通知绑定提供服务(参见5.3节)。

可以使用seL4_SchedContext_Unbind()从任何对象(绑定的或通过让渡获得SC的通知对象、TCBs)解除调度上下文的绑定。

被动线程将在调度上下文配置的CPU节点上运行，迁移在IPC期间完成。

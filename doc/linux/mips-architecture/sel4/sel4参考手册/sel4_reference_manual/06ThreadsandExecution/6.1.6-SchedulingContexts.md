### 6.1.6  调度上下文[^1]

线程的CPU执行时间是通过调度上下文对象来控制的。seL4_SchedControl_Configure()用以微秒为单位的*预算时间(b)*和*周期(p)*两元组(参见第6.1.8节)设置调度上下文。两元组(b, p)构成了线程执行时间的上限 — 内核不允许线程在任一p微秒内运行超过b微秒的时间。但是，b/p并不代表执行时间的下限，因为一个线程必须要在所有可运行线程中拥有最高或与之同等的优先级，才能保证被调度，而且内核也不执行准入测试[^2]。因此，设置了时间参数并不代表一定可被调度。如果多个相同优先级的线程都有可用预算，它们将按先入先出顺序调度，并在预算过期后应用轮转调度(RoundRobin)。

一个调度上下文可以被调度器选中，如，有可用的执行时间预算，就称其为*活跃的*。轮转线程和sporadic线程的预算充值和补充规则不同。对于轮转线程，每次改变当前节点的调度上下文时都要对预算进行充值，预算耗尽时会立即重新补充。

b == p的线程是轮转线程[^3]，b充当时间片。其它情况，内核使用*sporadic server*算法强制时间隔离，确保对所有可能的p，b/p都不能被超越。理论上，sporadic server使用以下算法提供时间隔离 — 阻止线程超出分配给它的时间预算:

- 当线程开始执行时，记录当前时间Ts。

- 当线程在时间T停止执行时(阻塞或被抢占)，在Ts + p处安排一个补充值(T - Ts)，即已消耗时间，再从当前正用的预算中减去这个值。

seL4通过在每个调度上下文中维护一个零散补充单元的有序列表 - 简称补充列表(refills)来实现算法。每个补充单元包含一对时间元组：预算启用时间(rTime)和预算数量(rAmount)。当线程执行时，它会不断地消耗补充列表的头单元预算。如果头单元的预算启用时间尚未到来，则绑定到该调度上下文的线程将被放置到等待队列中，等待更多的预算。

轮转线程也可被视为sporadic线程，除了一种情况外：预算如何充值。轮转线程只有两个补充单元，都随时可以使用。当轮转线程停止执行时，已消耗预算从头单元移到尾单元。一旦头单元预算耗尽，线程将移至其优先级调度队列的尾部等待轮转调度。

sporadic线程根据可以使用的补充单元数量而有不同的行为，这些单元数量是有限制的。开发者有两个选项来配置补充列表的大小：

- 单个调度上下文中补充单元的最大数量，在seL4_Untyped_Retype()调用时由调度上下文的大小决定。

- 每个调度上下文有一个extra_refills参数，指定实际使用的补充单元数量 - 该额外值加基本值2，其大小受上条限制。

执行时间短的线程(如中断处理程序)和不经常被抢占的线程应该用较少的补充单元，而运行时间较长、b值较大的线程应该有更多的补充单元。绑定到extra_refills为0的调度上下文的线程，将周期执行 —  任务消耗它们的头单元预算或出让cpu，然后直到下一个周期再次调度。

由于补充单元数量有限，当一个节点的SC发生改变，而要调出的SC又没有足够空间来存储新的补充单元时，当前补充单元会被删除以腾出空间；如果其下一个预算启用时间还没到来，则会导致抢占[^4]。配置了较多补充单元的调度上下文将消耗更接近它们整个预算的cpu时间，因为它们可以被抢占或更频繁地切换线程，而无需担心增加补充单元数量问题。但是，补充列表的碎片化将使调度开销增大。

每当线程执行时，它都会消耗当前调度上下文中的预算。系统调用seL4_Yield()可以用来主动让渡剩余预算，然后线程将阻塞直到下个补充单元可用。

可以使用seL4_TCB_Configure()或seL4_SchedContext_Bind()将线程绑定到调度上下文，这两个调用具有相同的效果，seL4_TCB_Configure()还允许一次调用设置更多的线程参数字段。当一个线程被绑定到调度上下文时，如果它处于可运行状态，并且调度上下文是活跃的，那么它将被添加到调度器中。

[^1]: 论文和算法链接：
    1. http://ts.data61.csiro.au/publications/csiro_full_text/Lyons_MAH_18.pdf
    2. https://github.com/pingerino/phd/blob/master/phd.pdf

[^2]: 指测试评估参数是否合理、系统是否能够承载、适不适合加入就绪队列等。

[^3]: 内部实现上是令p=0表示轮转线程。

[^4]: 这里的抢占更多地是指运行时长被抢占，而不是通常的执行权被抢占。即，当前补充单元中剩余的预算在这个周期内不会再执行了，在这个p内b的一部分被剥夺了。

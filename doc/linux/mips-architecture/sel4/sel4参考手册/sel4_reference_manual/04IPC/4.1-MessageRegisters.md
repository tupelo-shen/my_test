## 第4.1节  消息寄存器

每个消息包含一些`消息字`和一些可选的能力。`消息字`存储在线程的`消息寄存器`中。消息寄存器都有编号，开始的几个消息寄存器使用CPU的物理寄存器实现，其余的存储在`IPC缓冲区`的固定内存区域。

这种设计的原因是效率：非常短的消息不需要使用内存，提高读取的速度。每个线程都有`IPC缓冲区`。

每个消息都有一个标签`tag`，数据结构为`seL4_MessageInfo_t`。`tag`由四个域组成：`label`、`消息长度`、`能力数量`（`extraCaps`字段）和`已打开能力标识`（`capsUnwrapped`字段）。

1. 消息长度和能力数量

    决定了发送线程希望传递的消息寄存器数量和能力数量，亦可作为IPC结果，指示实际传输的消息寄存器和能力数量。

2. label

    当与其它线程进行IPC通信时，内核不解释`label`，而是作为消息的第一个有效载荷不加修改地传递出去； 但是，如果请求内核服务，内核要解释`label`，因为此时它的值是`系统调用号`。

3. `capsUnwrapped`字段

    仅用于接收端，指示能力接收的方式，在讲述能力传输的时候，再详细阐述。

IPC缓冲区使用`seL4_IPCBuffer`数据结构表示，如表4.1中所示。

>为了效率，内核应该使用尽可能多的物理寄存器来传输IPC消息。当传输的参数多于可用物理消息寄存器时，内核开始使用IPC缓冲区的`msg`字段来传输剩余的参数。需要注意的是，尽管前几个消息寄存器使用物理寄存器传递，但是，还是在`msg`数组中为物理消息寄存器保留了空间。例如，如果IPC传输或内核对象引用中，需要4个消息寄存器（假设架构中只有2个可用于消息传递的物理寄存器），那么参数1和2将通过消息寄存器传输，参数3和4将使用`msg[2]`和`msg[3]`。这允许用户空间的存根程序（stubs）根据需要将物理寄存器中传递的参数复制到`msg`数组的预留空间中。`tag`的情况与此类似，`seL4_IPCBuffer`结构中有这个字段的空间，但内核忽略它。用户空间的存根程序可能希望将`tag`从CPU寄存器复制到此字段，尽管内核提供的用户空间的存根程序并不这样做。

| 类型               | 名字         | 描述
| ------------------ | ------------ | ---
| seL4_MessageInfo_t | tag          | 消息指示标签
| seL4_Word[]        | msg          | 消息内容
| seL4_Word          | userData     | 用于支持用户库[^3]
| seL4_CPtr[]        | caps         | 要传输的能力
| seL4_CapData_t[]   | badges       | 接收到的端点能力标记
| seL4_CPtr          | receiveCNode | CNode句柄，用于寻址接收slot
| seL4_CPtr          | receiveIndex | 接收slot句柄，相对于receiveCNode
| seL4_Word          | receiveDepth | receiveIndex解析深度(位数)

表4.1：seL4_IPCBuffer数据结构。注意caps和badges字段使用结构中同一个内存位置

[^1]: label，译为标号是为了和后面要出现的badge区分。

[^2]: 当IPC用于请求内核服务时，内核要解释这个*标号*，因为它的值是系统调用号。

[^3]: libsel4提供了该字段设置和获取的函数。内核仅有寄存器数量较少的IA32架构利用此字段向内核传递引用的能力。


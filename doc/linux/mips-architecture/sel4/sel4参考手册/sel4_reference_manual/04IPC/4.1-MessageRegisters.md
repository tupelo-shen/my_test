## 第4.1节  消息寄存器

每个消息包含一些消息字和一些可选的能力。消息字通过将它们放在线程的*消息寄存器*中来发送或接收。消息寄存器都有编号，开始的几个消息寄存器使用物理CPU寄存器实现，其余的由称为 *`IPC buffer`*的固定内存区域来承担。这种设计的原因是效率：非常短的消息不需要使用内存。`IPC buffer`被分配给调用线程使用(参见第6.1节和10.3.7.11节)。

每个IPC消息都有一个*`tag`*，数据结构为`seL4_MessageInfo_t`。tag由四个域组成：label（标签）[^1]、消息长度、能力数量（`extraCaps`字段）和已打开能力标识（`capsUnwrapped`字段）。消息长度和能力数量决定了发送线程希望传递的消息寄存器数量和能力数量，或者作为IPC结果指示了实际传输的消息寄存器和能力的数量。内核不解释label[^2]，而是作为消息的第一个有效载荷不加修改地传递出去，例如，label可能被用来表示请求的操作。capsUnwrapped字段仅用于接收端，指示能力接收的方式，第4.2.2节对此进行了描述。

内核假设IPC缓冲区为表4.1中定义的`seL4_IPCBuffer`类型结构。内核使用尽可能多的物理寄存器来传输IPC消息，当传输的参数多于可用物理消息寄存器时，内核开始使用IPC缓冲区的msg字段来传输剩余的参数。注意，它在这个数组中为物理消息寄存器留下了空间。例如，如果IPC传输或内核对象引用需要4个消息寄存器(假设架构中只有2个可用于消息传递的物理寄存器)，那么参数1和2将通过消息寄存器传输，参数3和4将使用msg[2]和msg[3]。这允许用户级对象引用桩程序(stubs)根据需要将物理寄存器中传递的参数复制到msg数组预留空间。*`tag`*的情况与此类似，`seL4_IPCBuffer`结构中有这个字段的空间，但内核忽略它。用户级桩程序可能希望将消息指示标签从CPU寄存器复制到此字段，尽管内核提供的用户级桩程序并不这样做。

| 类型               | 名字         | 描述
| ------------------ | ------------ | ---
| seL4_MessageInfo_t | tag          | 消息指示标签
| seL4_Word[]        | msg          | 消息内容
| seL4_Word          | userData     | 用于支持用户库[^3]
| seL4_CPtr[]        | caps         | 要传输的能力
| seL4_CapData_t[]   | badges       | 接收到的端点能力标记
| seL4_CPtr          | receiveCNode | CNode句柄，用于寻址接收slot
| seL4_CPtr          | receiveIndex | 接收slot句柄，相对于receiveCNode
| seL4_Word          | receiveDepth | receiveIndex解析深度(位数)

表4.1：seL4_IPCBuffer数据结构。注意caps和badges字段使用结构中同一个内存位置

[^1]: label，译为标号是为了和后面要出现的badge区分。

[^2]: 当IPC用于请求内核服务时，内核要解释这个*标号*，因为它的值是系统调用号。

[^3]: libsel4提供了该字段设置和获取的函数。内核仅有寄存器数量较少的IA32架构利用此字段向内核传递引用的能力。


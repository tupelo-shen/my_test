### 4.2.4  呼叫与回复

如第2.2节所述，当用户引用端点能力调用seL4_Call()时，系统将采取一些特定的操作。首先，调用将执行与正常的seL4_Send()完全相同的操作。然后，在会合点所有正常的IPC过程发生后，seL4_Call()并不直接返回呼叫方，而是将检查被引用的端点能力是否有Grant或GrantReply权限：

- 如果没有，呼叫线程将被挂起，就像在其上调用了seL4_TCB_Suspend()一样。但这不影响已经发送的部分。

- 如果有的话，一个回复能力将被设置在接收者TCB的特定slot中，接收者端点能力的Grant权限将用于设置回复能力的Grant权限。然后，呼叫线程阻塞并等待回复。

回复能力在调用发生后即直接指向呼叫者线程，而不再与原始的端点能力相关联。即使后者被销毁，回复能力仍然存在，并指向仍在等待回复的呼叫者。

这个生成的回复能力或者通过seL4_Reply()直接引用，或者使用seL4_CNode_SaveCaller()将其保存到可寻址的slot中，以便稍后引用以进行seL4_Send()。这个特定的TCB槽不能用任何句柄来寻址，因为它不是任何CSpace的组成部分[^1]。

回复能力的引用方式与端点上的正常发送相同。回复能力隐含了写权限，因此消息将始终能够反馈回呼叫者。只有当回复能力具有Grant权限时，才能够在回复中传递能力，操作过程与第4.2.2节中描述的正常IPC传输完全相同。

与普通端点通信的主要区别在于，内核保证引用回复能力不会阻塞：如果您拥有回复能力，那么它所指向的线程一定正在等待应答。然而，与所有其他能力相反，回复能力是非拥有的 - 即它是个一次性的能力。这意味着，如果呼叫线程被销毁或以任何方式被修改，都可能导致无法再进行回复(如，呼叫者被seL4_TCB_Suspend()挂起)，内核将立即销毁这个回复能力[^2]。

一旦引用了回复能力，原来的呼叫者就会像执行了seL4_Recv()一样，恰到好处地接收到回复消息。特别是，它又可以继续运行了。

seL4_Call()操作的存在不仅仅是为了提高效率(将两个操作合并到一个系统调用中)，它与seL4_Send()后面紧跟着seL4_Recv()的区别在于，它允许某些系统采用比传统方式更少的设置来更有效地工作。特别是，可以保证呼叫者收到的应答确实来自其信息的实际接收者，而不必检查任何类型的标记。

[^1]: 它实际位于内部称为TCB CNode的数据结构中。

[^2]: 这个回复能力在成功使用后，也会被内核立即销毁。

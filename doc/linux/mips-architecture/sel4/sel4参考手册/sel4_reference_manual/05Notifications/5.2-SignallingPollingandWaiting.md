## 第5.2节  发信号、轮询和等待

seL4_Signal()方法将所引用通知能力的标记与通知字进行位或，来更新通知信号标识，它还会释放等待通知的第一个线程(如果有的话)。因此，seL4_Signal()的工作方式类似于并发地发送多个信号量(由标识中设置的位表示)。如果信号发送者能力是无标记的或者说标记值是0，该操作将降级为只唤醒等待通知的第一个线程(参见下面的内容)[^1]。

seL4_Wait()方法的工作原理类似于信号量集合上select样式的等待：如果在调用seL4_Wait()时通知字为0，则调用程序将阻塞；否则，调用将立即返回，并将通知字设置为0，获得的通知字值返回给调用者[^2]。

seL4_Poll()与seL4_Wait()相同，只是如果没有任何信号在等待接收，调用将立即返回，而不会阻塞。

如果在调用seL4_Signal()时有线程正在等待通知信号，则第一个排队的线程将接收到通知，所有其他线程继续等待，直到下一次通知发出。

[^1]: 无人等待接收通知的情况下，发出的通知信号会积累，即标记位或，一旦有人接收，则会取走全部的标记集合，相当于接收到了并发信号；无标记或标记值为0的位或操作无意义，也就谈不上信号积累。所以说“降级”。

[^2]: 准确地说，通知字与收没收到信号无关，因为seL4实现上是判断和调整通知对象上的队列状态，通知字仅用于标识和区分信号。存在这样的情况，通知字为0，而队列状态为活跃，即有人已发出了信号，只不过它没有标记或者说它的标记为0，seL4_Wait()会成功地返回，并将标记值0返回给调用者。

`elfloader`负责在`ARM`和`RISC`平台上为`seL4`的运行准备好硬件。使用CPIO归档文件加载内核和用户镜像，初始化其它CPU核（如果`SMP`被使能，并为内核建立初始化页表。

## 1 ARM

在ARM平台上，`elfloader`支持4种方式引导：二进制镜像，`u-boot`使用的`uImage`镜像，`ELF`文件，`EFI`可执行文件。每种方法都有些许不同。它还可以为`seL4`提供一个`DTB`文件，从引导程序中传递，或者包含在CPIO归档文件中都可以。

1. (EFI only) `Elfloader`的入口点是`_gnuefi_start`；

2. (EFI only) `Elfloader`重定向自己；

3. `Elfloader`自身的入口点`_start`。位于`arch-arm/<arch_bitness>/crt0.S`；

4. `Elfloader`初始化[driver framework](https://docs.sel4.systems/projects/elfloader/#driver-framework)，使能`UART/printf`；

5. `Elfloader`加载内核，用户镜像和DTB，确定内核需要被映射到内存的位置；

6. 如果内核窗口与`elfloader`的代码重叠：
    
    * (AArch32 EFI only) `elfloader`自己重新定位。有关重定位逻辑的详细解释，请参阅`relocate_below_kernel`；
    
    * (Other platforms) `elfloader`中止；

7. `elfloader`继续引导。如果它重新定位自己，它将重新初始化驱动程序模型；

8. 如果`elfloader`处于`HYP`模式，但`seL4`没有配置为支持`HYP`，它将离开`HYP`模式；

9. The `elfloader`为内核建立初始页表（参考`init_hyp_boot_vspace`或`init_boot_vspace`）；

10. 如果`SMP`使能，`elfloader`将启动所有的其它CPU核；

11. `elfloader`使能`MMU`内存管理单元；

12. `elfloader`启动`seL4`，传递用户镜像和DTB文件。

#### 1.1 二进制镜像

`elfloader`期望从某个基地址开始执行，`shoehorn`小工具可以产生这个基地址。可以在`build`目录下运行下面的命令获取正确的地址：

```
$ arm-linux-gnueabi-objdump -t elfloader | grep _text
0080f000 g       .start 00000000 _text
```

在构建目录下， `0x0080f000`就是基地址。

在`aarch64`架构上，`elfloader`尝试移动自己到正确的地址。但是，如果加载地址和正确地址太接近，这将失败，因为重定位代码将被覆盖。（TODO: 目前不太明白）

也可以通过在`CMake`中设置`IMAGE_START_ADDR`变量来覆盖`shoehorn`，从而硬编码一个加载地址。

#### 1.2 U-Boot

`elfloader`可以根据Linux内核对`ARM/ARM64`的引导约定来引导。如果提供了`DTB`，则将其传递给`seL4`，然后，`seL4`将其传递给root任务。

#### 1.3 ELF

`elfloader`支持作为`ELF`映像执行(通过`U-Boot`中的`bootelf`或类似的方式)。

#### 1.4 EFI

`elfloader`支持EFI，基于`gnu-efi`。它将根据需要重新定位自己，并支持从`EFI实现`中加载`DTB`。

## 2 RISC-V

The elfloader on RISC-V basically follows the ARM platforms. However, due to the lack of available platforms, only two ways are currently supported actively: building it as ELF file or binary image. In bot cases the platform must provide a [SBI](https://github.com/riscv/riscv-sbi-doc) implementation, which will be used by the elfloader for the log output channel and the multicore boot. The seL4 build system allows building [OpenSBI](https://github.com/riscv/opensbi) with the elfloader as payload. The [bbl](https://github.com/riscv/riscv-pk) Support has been dropped, because it is superseded by OpenSBI.

## 3 Driver framework

The elfloader provides a driver framework to reduce code duplication between platforms. Currently the driver framework is only used for UART output, however it is designed with extensibility in mind. In practice, this is currently only used on ARM, as RISC-V uses SBI for UART, and SBI has no device tree entries. However, in the future it may become useful on RISC-V.

The driver framework uses a header file containing a list of devices generated by the `hardware_gen.py` utility included in seL4. Currently, this header only includes the UART specified by the `stdout-path` property in the DTB. Each device in the list has a compatible string (`compat`), and a list of addresses (`region_bases[]`) which correspond to the regions specified by the `reg` property in the DTB.

Each driver in the elfloader has a list of compatible strings, matching those found in the device tree. For instance, the 8250 UART driver, used on Tegra and TI platforms has the following:

```c
static const struct dtb_match_table uart_8250_matches[] = {
    { .compatible = "nvidia,tegra20-uart" },
    { .compatible = "ti,omap3-uart" },
    { .compatible = "snps,dw-apb-uart" },
    { .compatible = NULL /* sentinel */ },
};
```

Each driver also has a ‘type’. Currently the only type supported is DRIVER_UART. The type indicates the type of struct that is found in the ops pointer of each driver object, and provides type-specific functionality. (For instance, UART drivers have a elfloader_uart_ops struct which contains a putc function). Finally, drivers also provide an init function, which is called when the driver is matched with a device, and can be used to perform device-specific setup (e.g. setting the device as the UART output).

Finally, each driver has a `struct elfloader_driver` and a corresponding `ELFLOADER_DRIVER` statement. Taking the 8250 UART driver as an example again:

```
static const struct elfloader_driver uart_8250 = {
    .match_table = uart_8250_matches,
    .type = DRIVER_UART,
    .init = &uart_8250_init,
    .ops = &uart_8250_ops,
};

ELFLOADER_DRIVER(uart_8250);
```

#### 3.1 UART

The driver framework provides a “default” (`__attribute__((weak))`) implementation of `plat_console_putchar`, which calls the `putc` function for the elfloader device provided to `uart_set_out` - discarding all characters that are given to it before `uart_set_out` is called. This can be overridden if you do not wish to use the driver framework (e.g. for very early debugging).

## 4 Porting the elfloader

#### 4.1 To ARM

Once a kernel port has been started (and a DTB provided), porting the elfloader to a platform is reasonably straightforward.

Most platform-specific information is extracted from a DTB, including available physical memory ranges. If the platform uses a UART compatible with another platform, even the UART will work out of the box. In other cases, it might be necessary to add a new `dtb_match_table` entry to an existing driver, or add a new driver (which is fairly trivial - only the `match_table` and `putchar` functions from an existing driver would need to be changed).

An appropriate image type needs to be selected. By default `ElfloaderImage` is set to `elf`, however, various platform-specific overrides exist and can be found in `ApplyData61ElfLoaderSettings` in this repo, at `cmake-tool/helpers/application_settings.cmake`.

#### 4.2 To RISC-V

TODO - it seems there’s not actually that much that needs to be done on the elfloader side.
[TOC]

本教程将会讲解`seL4`微内核中的线程使用方法。

## 1 前提条件

1. [建立虚拟开发环境](https://docs.sel4.systems/HostDependencies)；
2. [能力教程](https://docs.sel4.systems/Tutorials/capabilities)；
3. [地址映射教程](https://docs.sel4.systems/Tutorials/mapping)。

## 2 学习目标

1. 了解术语TCB；
2. 学习如何在相同的地址空间中启动一个新线程；
3. 理解如何读取和更新TCB寄存器的状态；
4. 学习如何挂起和恢复线程；
5. 理解线程优先级和调度器如何根据它们工作的；
6. 对`exception`和`debug fault`处理程序有一个基本的理解。

## 3 背景知识

#### 3.1 任务控制块（TCB）

`seL4`提供`thread`来表示执行上下文并管理处理器时间。`seL4`中的线程是由线程控制块对象(`TCB`)实现的，每个内核线程有一个`TCB`。

`TCB`包含的内容如下：

1. 优先级和最大控制优先级（`MCP`）；
2. 通用寄存器和浮点寄存器；
3. CSpace能力；
4. VSpace能力；
5. 发送Fault消息的目标端点能力；
6. `reply`能力槽；

#### 3.2 调度模型

`seL4`调度器是一个基于优先级的时间片轮转调度器。调度器选择的线程都是处于运行态的：也就是说，从任何IPC操作中恢复并且没有被阻塞的线程。

* 优先级

    `seL4`的优先级范围是`0-255`，其中255是最高优先级。调度器选择最高优先级的可运行线程。`libsel4`中，宏定义`seL4_MinPrio`和`seL4_MaxPrio`分别代表最低和最高优先级。

    TCB还提供最大控制优先级（MCP）。
    TCBs also have a maximum control priority (MCP), which acts as an informal capability over priorities. When setting the priority of a TCB, an explicit TCB capability must be provided to derive the authority from to set the priority. The priority being set is checked against the authority TCB’s MCP and the targer priority is greater, the operation fails. The root task starts with both priority and MCP set to seL4_MaxPrio.

* Round robin

    When multiple TCBs are runnable and have the same priority, the are scheduled in a first-in first-out round-robin fashion. In more detail, kernel time is accounted for in fixed-time quanta referred to as ticks, and each TCB has a timeslice field which represents the number of ticks that TCB is eligible to execute until preempted. The kernel timer driver is configured to fire a periodic interrupt which marks each tick, and when the timeslice is exhausted round robin scheduling is applied. Threads can surrender their current tick using the seL4_Yield system call.

* Domain scheduling

    In order to provide confidentiality seL4 provides a top-level hierarchical scheduler which provides static, cyclical scheduling of scheduling partitions known as domains. Domains are statically configured at compile time with a cyclic schedule, and are non-preemptible resulting in completely deterministic scheduling of domains.

    Threads can be assigned to domains, and threads are only scheduled when their domain is active. Cross-domain IPC is delayed until a domain switch, and seL4_Yield between domains is not possible. When there are no threads to run while a domain is scheduled, a domain-specific idle thread will run until a switch occurs.

    Assigning a thread to a domain requires access to the `seL4_DomainSet` capability. This allows a thread to be added to any domain.

    ```c
    /* Set thread's domain */
    seL4_Error seL4_DomainSet_Set(seL4_DomainSet _service, seL4_Uint8 domain, seL4_TCB thread);
    ```

#### 3.3 线程属性

`seL4`线程是通过作用在TCB对象上的调用来完成的。

## 4 练习

本教程创建一个线程，相同的地址空间，并且可以给线程传递参数。另外，学习如何debug一个`VM Fault`错误。


#### 4.1 CapDL加载器

Previous tutorials have taken place in the root task where the starting CSpace layout is set by the seL4 boot protocol. This tutorial uses a the capDL loader, a root task which allocates statically configured objects and capabilities.

The capDL loader parses a static description of the system and the relevant ELF binaries. It is primarily used in [Camkes](https://docs.sel4.systems/CAmkES/) projects but we also use it in the tutorials to reduce redundant code. The program that you construct will end up with its own CSpace and VSpace, which are separate from the root task, meaning CSlots like seL4_CapInitThreadVSpace have no meaning in applications loaded by the capDL loader.

Information about CapDL projects can be found [here](https://docs.sel4.systems/CapDL.html).

#### 4.2 配置TCB

当第一次构建并运行本教程时，应该看到如下内容:

```
Hello, World!
Dumping all tcbs!
Name                                        State           IP          Prio    Core
--------------------------------------------------------------------------------------
tcb_threads                                 running         0x4012f4    254     0
idle_thread                                 idle            0           0       0
rootserver                                  inactive        0x4014bf    255     0
<<seL4(CPU 0) [decodeInvocation/633 T0xffffff8008149400 "tcb_threads" @4012f4]:
        Attempted to invoke a null cap #0.>>
main@threads.c:47 [Cond failed: result]
    Failed to retype thread: 2
```

`Dumping all tcbs!`。上面的表是由系统调用`seL4_DebugDumpScheduler()`产生的。`seL4`中，如果配置编译的是debug版本内核，会提供一组debug用的系统调用。具体的定义都在`libsel4`中。`seL4_DebugDumpScheduler()`用来打印调度器的当前状态，在系统的开发阶段，这种debug系统调用还是非常方便的。

在TCB表之后，可以看到`seL4_Untyped_Retype`调用由于无效参数而失败。加载器会设置以下能力和符号:

```c
// the root CNode of the current thread
extern seL4_CPtr root_cnode;
// VSpace of the current thread
extern seL4_CPtr root_vspace;
// TCB of the current thread
extern seL4_CPtr root_tcb;
// Untyped object large enough to create a new TCB object

extern seL4_CPtr tcb_untyped;
extern seL4_CPtr buf2_frame_cap;
extern const char buf2_frame[4096];

// Empty slot for the new TCB object
extern seL4_CPtr tcb_cap_slot;
// Symbol for the IPC buffer mapping in the VSpace, and capability to the mapping
extern seL4_CPtr tcb_ipc_frame;
extern const char thread_ipc_buff_sym[4096];
// Symbol for the top of a 16 * 4KiB stack mapping, and capability to the mapping
extern const char tcb_stack_base[65536];
static const uintptr_t tcb_stack_top = (const uintptr_t)&tcb_stack_base + sizeof(tcb_stack_base);
```

* 练习1：使用上面提供的能力，修正`seL4_Untyped_Retype`调用，在`tcp_cap_slot`处创建新的TCB对象。

    ```c
    int main(int c, char* arbv[]) {

    printf("Hello, World!\n");

    seL4_DebugDumpScheduler();
    // TODO: 修改参数
    seL4_Error result = seL4_Untyped_Retype(tcb_untyped,    /* <-seL4_CapNull */ 
                                            seL4_TCBObject, 
                                            seL4_TCBBits, 
                                            root_cnode,     /* <-seL4_CapNull */ 
                                            0, 
                                            0, 
                                            tcb_cap_slot,   /* <-seL4_CapNull */
                                            1
                                            );
    ZF_LOGF_IF(result, "Failed to retype thread: %d", result);
    seL4_DebugDumpScheduler();
    ```

    一旦创建了TCB，它将在`seL4_DebugDumpScheduler()`输出中显示为:`child of: 'tcb_threads'`。但是，接下来我们又会看到另一个错误：

    ```
    <<seL4(CPU 0) [decodeInvocation/633 T0xffffff8008149400 "tcb_threads" @4012f4]:\
     Attempted to invoke a null cap #0.>>
    main@threads.c:60 [Cond failed: result]
    Failed to configure thread: 2
    ```

* 练习2：现在我们已经有了一个TCB对象，设置其能力空间和虚拟空间，与当前线程相同。使用上面提供的IPC缓存，但是不设置Fault处理程序，因为内核会打印Fault信息。

    ```c
    //TODO: 修改参数
    result = seL4_TCB_Configure(tcb_cap_slot,       /* _service:
                                                        要操作的TCB能力 */
                                seL4_CapNull,       /* fault_ep: 
                                                        当线程出错时，接收IPC消息的端点的能力指针。
                                                        该能力就在我们正要配置的线程的能力空间中 */
                                root_cnode,         /* cspace_root:
                                                        新root能力空间 */
                                0,                  /* cspace_root_data: 
                                                        可选，设置新root能力节点guard位及其大小。
                                                        如果设置为0，则不起作用 */
                                root_vspace,                  /* vspace_root:
                                                        新root虚拟空间 */
                                0,                  /* vspace_root_data: 
                                                        X86或ARM，该参数无效 */ 
                                (seL4_Word) thread_ipc_buff_sym,   /* buffer: 
                                                        IPC缓存的位置。必须是512字节对齐。
                                                        IPC缓存不能跨page */
                                tcb_ipc_frame       /* bufferFrame: 
                                                        指向IPC缓存页的能力 */
                                );
    ZF_LOGF_IF(result, "Failed to configure thread: %d", result);
    ```

    编译运行，会得到下面的错误：

    ```
    main@threads.c:84 [Cond failed: result]
    Failed to set the priority for the new TCB object.
    ```

#### 4.3 设置线程优先级

新创建的线程优先级为0，而CapDL加载器创建的线程优先级为254。我们接下来将优先级手动设为254。

* 练习： 调用`seL4_TCB_SetPriority `设置优先级。记住：要设置优先级，首先调用者线程必须被授权可以这样做。在本示例中，主线程可以使用自己的TCB能力中的MCP属性（254）进行设置。

    ```c
    // TODO：设置优先级
    result = seL4_TCB_SetPriority(tcb_cap_slot, /* 要操作的TCB能力 */
                                  root_tcb,     /* 可以使用MCP设置优先级的TCB能力 */
                                  254           /* 优先级 */
                                  );
    ZF_LOGF_IF(result, "Failed to set the priority for the new TCB object.\n");
    seL4_DebugDumpScheduler();
    ```

    输出结果：

    ```
    Name                                  State     IP                  Prio    Core
    --------------------------------------------------------------------------------------
     child of: 'tcb_threads'           inactive     0                   254     0
                 tcb_threads            running     0x4012f4            254     0
                 idle_thread               idle     0                   0       0
                  rootserver           inactive     0x4014bf            255     0
    <<seL4(CPU 0) [decodeInvocation/633 T0xffffff8008149400 "tcb_threads" @4012f4]: 
     Attempted to invoke a null cap #0.>>
    main@threads.c:100 [Err seL4_InvalidCapability]:
    Failed to write the new thread's register set.
    Did you write the correct number of registers? See arg4.
    ```

#### 4.4 设置初始寄存器状态

至此，我们已经创建好了一个线程对象。但是，还需要设置正确的PC和SP值，要不然，线程会立马崩溃。

`libsel4utils`提供了一些辅助函数，用于设置寄存器内容。注意：假设堆栈是向下增长的。

* 练习：设置新线程调用函数`new_thread`。可以通过debug系统调用验证设置的PC值是否正确。

    ```c
    seL4_UserContext regs = {0};
    int error = seL4_TCB_ReadRegisters( tcb_cap_slot,   /* 要设置的线程能力 */ 
                                        0,              /* 设置要挂起的原线程 */
                                        0,              /* 架构标志，ARM/X86没有意义 */
                                        sizeof(regs)/sizeof(seL4_Word), 
                                                        /* 要读取的寄存器数量 */
                                        &regs           /* 线程上下文指针 */
                                        );
    ZF_LOGF_IFERR(error, "Failed to read the new thread's register set.\n");

    // TODO: 设置PC
    sel4utils_set_instruction_pointer(&regs, (seL4_Word)&new_thread);
    // TODO: 设置SP
    sel4utils_set_stack_pointer(&regs, tcb_stack_top);
    // TODO: 将设置的寄存器值写入TCB块中
    error = seL4_TCB_WriteRegisters(tcb_cap_slot,   /* 要设置的线程能力 */
                                    0,              /* 要恢复的目的线程 */
                                    0,              /* 架构标志，ARM/X86没有意义 */
                                    sizeof(regs)/sizeof(seL4_Word),
                                                    /* 要设置的寄存器数量 */
                                    &regs           /* 线程上下文指针 */
                                    );
    ZF_LOGF_IFERR(error, "Failed to write the new thread's register set.\n"
                  "\tDid you write the correct number of registers? See arg4.\n");
    seL4_DebugDumpScheduler();
    ```

#### 4.5 启动线程

* 练习： 启动新线程

    ```c
    // TODO: resume the new thread
    error = seL4_TCB_Resume(tcb_cap_slot);
    ZF_LOGF_IFERR(error, "Failed to start new thread.\n");
    ```
    
    编译运行：
    
    ```
    Hello2: arg1 0, arg2 0, arg3 0
    ```

    当然，后边会有其它错误信息。

#### 4.6 传递参数

目前，我们传递给新线程的实参都是`0`。除了直接操作线程的寄存器之外，还可以使用辅助函数`sel4utils_arch_init_local_context`设置参数，它还可以传递给线程参数。

* 练习：使用辅助函数`sel4utils_arch_init_local_context`修改传递给线程的函数`new_thread()`的参数为1，2，3。

    ```c
    #if 0   /* 直接操作寄存器 */
    // TODO: 设置PC
    sel4utils_set_instruction_pointer(&regs, (seL4_Word)&new_thread);
    // TODO: 设置SP
    sel4utils_set_stack_pointer(&regs, tcb_stack_top);
    #else   /* 辅助函数 sel4utils_arch_init_local_context */
    int test_arg2 = 2;
    sel4utils_arch_init_local_context((void*)new_thread,
                                  (void *)1, (void *)2, (void *)3,
                                  (void *)tcb_stack_top, &regs);
    #endif
    ```

#### 4.7 解决fault错误

至此，您已经创建并配置了一个新线程，并为其提供了初始参数。接下来，我们解决掉Fault错误。因为当前线程没有Fault处理程序，所以，我们只能根据内核打印的错误信息进行手动解决。

在下面的打印信息中，我们发现有一个`cap fault`发生。第一行显示的内容说明，内核不能发送`fault`信息给`fault handler`，因为我们前面没有设置错误处理程序。然后，打印错误的具体信息。`fault`是一个`VM fault`。新线程尝试访问地址`0x2`，但它是一个不合法，没有映射的地址。程序发生错误的PC值为`0x401e9f`。

错误状态寄存器的值（0x4）也会被打印，这个需要根据相关的芯片手册进行解读。另外，内核还会打印当前堆栈的信息。堆栈打印的信息数量是可以配置，使用`KernelUserStackTraceLength`这个cmake变量。

```
Caught cap fault in send phase at address 0
while trying to handle:
vm fault on data at address 0x2 with status 0x4
in thread 0xffffff8008149c00 "child of: 'tcb_threads'" at address 0x401e9f
With stack:
0x42bfc0: 0x0
0x42bfc8: 0x3
0x42bfd0: 0x2
0x42bfd8: 0x1
0x42bfe0: 0x0
0x42bfe8: 0x1
0x42bff0: 0x0
0x42bff8: 0x0
0x42c000: 0x0
0x42c008: 0x0
0x42c010: 0x0
0x42c018: 0x0
0x42c020: 0x0
0x42c028: 0x0
0x42c030: 0x0
0x42c038: 0x0
```

为了调查这个错误，我们可以使用`objdump`命令工具反汇编ELF文件。然后，查找造成错误的指令位置。ELF文件位于`./<BUILD_DIR>/<TUTORIAL_BUILD_DIR>/threads`文件中。

    objdump -Dts threads > threads.S

反汇编结果：

```
0000000000401e61 <new_thread>:
  401e61:   55                      push   %rbp                 /* 栈基寄存器压栈 */
  401e62:   48 89 e5                mov    %rsp,%rbp            /* 将栈顶保存到栈基寄存器中 */
  401e65:   48 83 ec 30             sub    $0x30,%rsp           /* 记录栈底位置 */
  401e69:   48 89 7d e8             mov    %rdi,-0x18(%rbp)     /* 参数1压栈 */
  401e6d:   48 89 75 e0             mov    %rsi,-0x20(%rbp)     /* 参数2压栈 */
  401e71:   48 89 55 d8             mov    %rdx,-0x28(%rbp)     /* 参数3压栈 */
  401e75:   48 8b 4d d8             mov    -0x28(%rbp),%rcx     /* 参数3写入寄存器rcx中 */
  401e79:   48 8b 55 e0             mov    -0x20(%rbp),%rdx     /* 参数2写入寄存器rdx中 */
  401e7d:   48 8b 45 e8             mov    -0x18(%rbp),%rax     /* 参数1写入寄存器rax中 */
  401e81:   48 89 c6                mov    %rax,%rsi            /* 临时使用rax，将其值暂存 */
  401e84:   bf 88 31 41 00          mov    $0x413188,%edi       /* 0x413188是Hello2字符串在内存中的首地址 */
  401e89:   b8 00 00 00 00          mov    $0x0,%eax            /* printf浮动参数的数量为0（eax） */
  401e8e:   e8 46 b5 00 00          callq  40d3d9 <printf>      /* 跳转到printf函数 */
  401e93:   48 8b 45 e8             mov    -0x18(%rbp),%rax     /* 参数1写入寄存器rax中 */
  401e97:   48 89 45 f8             mov    %rax,-0x8(%rbp)      /* 保存参数1 */
  401e9b:   48 8b 45 e0             mov    -0x20(%rbp),%rax     /* 参数2写入寄存器rax中 */
  401e9f:   8b 10                   mov    (%rax),%edx          /* 取出参数2的值所指向的地址中的值 */
  401ea1:   48 8b 45 f8             mov    -0x8(%rbp),%rax      /* 取出参数1 */
  401ea5:   89 d7                   mov    %edx,%edi            /* 参数2指向的值，作为参数1指向的函数的参数1 */ 
  401ea7:   ff d0                   callq  *%rax                /* 跳转到参数1所指向的函数中执行 */
  401ea9:   eb fe                   jmp    401ea9 <new_thread+0x48>     /* 死循环 */
```

`new_thread()`函数源码：

```c
int new_thread(void *arg1, void *arg2, void *arg3) {
    printf("Hello2: arg1 %p, arg2 %p, arg3 %p\n", arg1, arg2, arg3);
    void (*func)(int) = arg1;
    func(*(int *)arg2);
    while(1);
}
```

我们源代码和反汇编结果进行结合分析。参数2`arg2`会被解引用，但是它却是我们随便设置的，并没有指向合法的地址值。

所以，我们需要传递一个合法的`arg2`值，比如，一个全局变量的地址。修改后的源代码如下所示：

```c
int test_arg2 = 2;
sel4utils_arch_init_local_context((void*)new_thread,
                                  (void *)1, (void *)&test_arg2, (void *)3,
                                  (void *)tcb_stack_top, &regs);
```
编译运行：

```
Hello2: arg1 0x1, arg2 0x42ce4c, arg3 0x3
Caught cap fault in send phase at address 0
while trying to handle:
vm fault on data at address 0x1 with status 0x4
in thread 0xffffff8008149c00 "child of: 'tcb_threads'" at address 0x1
With stack:
0x42bfb8: 0x401ea9
0x42bfc0: 0x0
0x42bfc8: 0x3
0x42bfd0: 0x42ce4c
0x42bfd8: 0x1
0x42bfe0: 0x0
0x42bfe8: 0x1
0x42bff0: 0x0
0x42bff8: 0x0
0x42c000: 0x0
0x42c008: 0x0
0x42c010: 0x0
0x42c018: 0x0
0x42c020: 0x0
0x42c028: 0x0
0x42c030: 0x0
```

又发生了另一个错误，新线程期望参数`arg1`是一个指向函数的指针，但实际上我们传递的是`(void *)1`，这肯定是非法的。

传递一个函数的地址给`arg1`，该函数打印参数`arg2`的值。函数如下：

```c
void test_arg1_func(int arg)
{
    printf("%s_%d: %d\n", __FUNCTION__, __LINE__, arg);
}
```

编译运行：

```
Hello2: arg1 0x401eab, arg2 0x42ce4c, arg3 0x3
test_arg1_func_38: 2
```

## 5 高级练习

1. 使用不同的TCB操作函数改变新线程的属性或对象；
2. 研究设置不同的优先级对调度线程运行的影响；
3. 使用全局内存实现同步原语；
4. 尝试创建更多线程对象；

[TOC]

本教程将会讲解`seL4`微内核中的虚拟内存管理。

## 1 前提条件

1. [建立虚拟开发环境](https://docs.sel4.systems/HostDependencies).
2. [能力教程](https://docs.sel4.systems/Tutorials/capabilities)

## 2 学习目标

1. `seL4`中如何映射内存、解除内存映射；

## 3 背景知识

#### 3.1 虚拟内存

`seL4`微内核中，除了操作硬件内存页管理的部分之外，没有提供虚拟内存管理。用户态必须提供虚拟内存管理的手段。

同`Linux`内核一样，`seL4`内核占用了虚拟内存的高地址空间。其余的虚拟内存空间，用户可以自由分配。对于32位系统，0xE0000000以上的虚拟地址空间由内核使用。这个变量`kernelBase`，可以根据平台进行修改。

> `kernelBase`，在最新的seL4微内核中，该变量已经被删除。`KERNEL_ELF_BASE`宏定义代替之。


#### 3.2 页表数据结构

系统的启动阶段，`seL4`使用顶层的虚拟内存对象初始化`root`任务，其被称为`VSpace`（虚拟空间）。`root`任务的能力空间中留有一个固定的能力槽`seL4_CapInitThreadVSpace`，在该槽中存储着`VSpace`对应的能力。不同的架构，该能力对应着不同的对象类型。如下表所示：

| 架构 | 虚拟空间对象（VSpace）|
| ---- | --------------------- |
| aarch32 | seL4_PageDirectory |
| aarch64 | seL4_PageGlobalDirectory |
| ia32    | seL4_PageDirectory |
| x86_64  | seL4_PML4 |
| RISC-V  | seL4_PageTable |

> <font color="blue">为什么每个平台的虚拟内存的顶层数据结构不一样？</font> 

除了顶层的数据结构之外，内存映射还需要一些中间的数据结构。这些数据对象，每个平台也不一样。如下表所示：

| 架构 | 对象 |
| ---- | --------------------- |
| aarch32 | seL4_PageTable |
| aarch64 | seL4_PageUpperDirectory<br>seL4_PageDirectory<br>seL4_PageTable |
| ia32    | seL4_PageTable |
| x86_64  | seL4_PDPT<br>seL4_PageDirectory<br>seL4_PageTable |
| RISC-V  | seL4_PageTable |

本教程主要是讲解`x86_64`架构。但是，涉及的虚拟内存管理的APIs对其它的平台也是适用的。

每一级的页表数据结构都可以被调用。下面就是一个`x86_64`架构下映射`seL4_PDPT`对象的示例：

```c
/* map a PDPT at TEST_VADDR */
error = seL4_X86_PDPT_Map(pdpt, seL4_CapInitThreadVSpace, TEST_VADDR, seL4_X86_Default_VMAttributes);
```

所有的映射函数都至少需要3个参数：

* 要映射对象所在的虚拟空间；
* 映射对象对应的虚拟地址；
* 虚拟内存的属性；

如果提供的虚拟地址没有和各级页表数据对象的大小对齐，`seL4`将会屏蔽掉未使用的位。比如，一个4K大小的页要映射到地址`0xDEADBEEF`，最终会被映射到地址`0xDEADB000`。

虚拟内存地址的属性，决定了是否使用Cache，这往往依赖于架构。`seL4_X86_Default_VMAttributes`之类的内存地址属性，可以在`libsel4`中找到。

#### 3.3 内存页

一旦将某一范围内的虚拟地址映射了中间页表数据结构对象，那么就可以通过调用页帧能力将真实的物理页帧映射到那段范围内的虚拟地址空间中。下面的代码段展示了将一个物理页帧映射到虚拟地址`TEST_VADDR`的方法：

```
/* 在TEST_VADDR映射一个只读page */
error = seL4_X86_Page_Map(frame,
                          seL4_CapInitThreadVSpace,
                          TEST_VADDR,
                          seL4_CanRead,
                          seL4_X86_Default_VMAttributes
                          );
```

为了页映射成功，所有的中间页表结构数据对象都必须被映射。`libsel4`中的`seL4_MappingFailedLookupLevel()`函数可以查看哪一级的页表结构没有被映射。值得注意的是，为了多次映射同一个页帧，必须要拷贝那个页帧能力多次：也就是说，每个页帧能力只能对应一个映射关系。

参数的话，除了需要映射中间页表数据结构需要的3个参数外，页映射还需要`rights`参数，决定映射的类型。比如，上面的示例中，就是映射一个只读页。

###### 3.3.1 类型和大小

页类型和大小是依赖于架构的。对于x86和ARM架构，不同的页对应不同的对象类型，相应地，大小也不相同。而RISC-V，页具有相同的对象类型，但是大小可变。不同的配置和硬件设置都会改变可利用页的大小。

## 4 练习

本教程使用了几个不同的辅助函数分配对象和能力。示例代码中，所有对象和CSlot的分配都已经完成。

#### 4.1 映射页目录、页表

直接编译运行教程原始代码，会得到下面的结果：

```
Missing intermediate paging structure at level 30
main@main.c:34 [Cond failed: error != seL4_NoError]
    Failed to map page
```

这是因为初始代码虽然提供了对`seL4_PDPT`对象的映射，但是缺少了两层中间页表结构。

* 练习：使用[seL4_X86_PageDirectory_Map](https://docs.sel4.systems/ApiDoc.html#map-5)和[seL4_X86_PageTable_Map](https://docs.sel4.systems/ApiDoc.html#map-5)映射一个`pd`对象：

```c
// TODO: 映射一个页目录对象
error = seL4_X86_PageDirectory_Map( pd,
                                    seL4_CapInitThreadVSpace,
                                    TEST_VADDR,
                                    seL4_X86_Default_VMAttributes
                                    );
assert(error == seL4_NoError);

// TODO: 映射页表pt对象
error = seL4_X86_PageTable_Map( pt,
                                seL4_CapInitThreadVSpace,
                                TEST_VADDR, 
                                seL4_X86_Default_VMAttributes
                                );
assert(error == seL4_NoError);
```
编译运行，会得到下面的结果：

```
Set x to 5
Caught cap fault in send phase at address 0
while trying to handle:
vm fault on data at address 0xa000000000 with status 0x7
in thread 0xffffff801fe08400 "rootserver" at address 0x401b99
With stack:
0x41eeb0: 0x41ef60
......
```

`page`成功映射，我们从虚拟地址`0xA000000000`读取到了值为0：因为内存分配阶段，`seL4`会将`non-device page`初始化为0。然后，代码尝试写该虚拟地址。但是，我们将虚拟地址映射为了只读属性，写操作的话，会造成`VM fault`。

因为初始任务没有`fault`处理程序（更多的内容会在`thread`一课中讲解），继而触发了`CSlot 0`上的能力错误。因为我们运行的是一个debug版本的内核，所以会打印所有错误的详细信息。

`VM fault`将会输出: 错误地址、错误状态寄存器的值和发生错误的指令指针(地址)。

#### 4.2 重映射一个页

通过重映射该`page`页，授予其`seL4_ReadWrite`权限。相关函数是[seL4_X86_Page_Map](https://docs.sel4.systems/ApiDoc.html#map-4)。

```c
// TODO: 重映射page
error = seL4_X86_Page_Map(frame, 
                          seL4_CapInitThreadVSpace, 
                          TEST_VADDR, 
                          seL4_ReadWrite, 
                          seL4_X86_Default_VMAttributes);
assert(error == seL4_NoError);
```

#### 4.3 解除映射

可以调用各级页表结构对应的`unmap`函数解除映射，或者直接删除对应的能力。

```c
// 第1种方法：删除frame能力
error = seL4_CNode_Revoke(seL4_CapInitThreadCNode,  /* seL4_CNode _service */
                          frame,                    /* seL4_Word index */
                          seL4_WordBits             /* seL4_Uint8 depth */
                          );
assert(error == seL4_NoError);

// 第2种方法：删除pt映射
error = seL4_X86_PageTable_Unmap(pt);
assert(error == seL4_NoError);
```

## 5 高级练习

1. 将本教程的内容移植到ARM或者RISC-V平台上；
2. 创建一个通用函数，将`seL4_MappingFailedLookupLevel`转换成`seL4`相应的对象。

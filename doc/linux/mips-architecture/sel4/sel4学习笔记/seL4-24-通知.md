[TOC]

## 1 前提条件

1. [建立虚拟开发环境](https://docs.sel4.systems/HostDependencies).
2. [Capabilities教程](https://docs.sel4.systems/Tutorials/capabilities)
3. [Mapping教程](https://docs.sel4.systems/Tutorials/mapping)
4. [Threads教程](https://docs.sel4.systems/Tutorials/threads)

## 2 学习目标

1. 理解如何在任务之间建立共享内存；
2. 能够使用通知对象在任务之间进行同步；
3. 知道如何使用`badge`区分通知。

## 3 背景知识

`通知`允许进程之间发送异步信号，主要用于中断处理或共享数据缓存之间的同步。

#### 3.1 通知对象

通知对象也是一种能力，通过调用这种能力，可以发送信号。通知对象由一个数据字(充当二进制信号量数组)和一个等待通知的tcb队列组成。

通知对象有3种状态：

1. 等待

    有tcb在此通知上排队等待信号。

2. 激活

    已有tcb在此通知对象上发出信号。

3. 空闲

    没有tcb排队，也没有tcb向该对象发出信号，因为它最后一次被设置为空闲。

#### 3.2 发信号

当一个任务向一个通知对象发出信号(使用`seL4_Signal`)时，会发生什么取决于对象的状态:

1. 空闲

    数据字被设置为用于发送信号的能力`badge`，通知对象被转化为激活状态。

2. 激活
    
    被用来发送信号给通知对象的能力的`badge`，与通知对象的数据字进行按位异或。

3. 等待

    TCB等待队列的`head`被激活，`badge`也会被发送给那个激活的TCB。如果等待队列为空，则控制对象被转换为空闲状态。

#### 3.3 等待

任务可以阻塞等待一个通知对象，调用`seL4_Wait`函数即可，

* 空闲

    如果通知对象此时处于空闲状态，TCB被加入等待队列，通知对象被转换为等待状态。

* 激活

    如果通知对象处于激活状态，TCB接收数据字，然后数据字被复位为0，且通知对象转变到空闲状态。

* 等待

    如果通知对象处于等待状态，则TCB被追加到等待队列中。

#### 3.4 轮询

通知对象也可以被轮询，而不是阻塞等待，相应的轮询函数是`seL4_Poll`，它是`seL4_Wait`的非阻塞版本。无论是什么状态，它都会立即返回。

## 4 中断和IPC

Notification objects can be used to receive signals of interrupt delivery, and can also be bound to TCBs such that signals and IPC can be received by the same thread. This is explained in more detail in the timer tutorial.

## 5 练习

本教程旨在通过通知对象和共享内存建立一个基本的生产者-消费者模型。本教程使用了CapDL加载器，有2个生产者进程（`producer_1.c`和`producer_2.c`）和1个消费者进程（`consumer.c`）。每个进程都可以访问一定数量的能力。

它们之间共享一个数据buffer，如果有数据，消费者进程就会处理这些数据。

直接编译运行初始代码，会有下面的结果输出：

```
Booting all finished, dropped to user space
Waiting for producer
```

#### 5.1 建立共享内存

Both producers start and block immediately, waiting for the consumer to send an IPC with the address of the shared mapping. We provide code below that sets up the shared page between producer 1 and the consumer:

    /* 为消费者1建立共享内存 */
    /* 首先，拷贝能力 */
    error = seL4_CNode_Copy(cnode,          /* 目的能力空间的根节点的能力指针
                                               必须与WORD_SIZE相同的深度 */
                            mapping_1,      /* dest_index: 目的CSlot的能力指针；
                                               从目的能力空间的根节点开始解析 */
                            seL4_WordBits,  /* dest_index的位数，也就是解析的深度 */
                            cnode,          /* 源能力空间的根节点的能力指针 */
                            buf1_frame_cap, /* src_index: 源CSlot的能力指针;
                                               从源能力空间的根节点开始解析 */
                            seL4_WordBits,  /* src_index的位数，也就是解析的深度 */ 
                            seL4_AllRights  /* 新能力继承的权限 */
                            );
    ZF_LOGF_IFERR(error, "Failed to copy cap");
    /* 地址映射 */
    error = seL4_ARCH_Page_Map( mapping_1, 
                                producer_1_vspace, 
                                BUF_VADDR, 
                                seL4_AllRights, 
                                seL4_ARCH_Default_VMAttributes);
    ZF_LOGF_IFERR(error, "Failed to map frame");

练习：理解上面的代码，为`producer_2`和`consumer`建立第2个共享page内存页。

```c
/* 为消费者和生产者2建立共享内存 */
/* 首先，拷贝能力 */
error = seL4_CNode_Copy(cnode,          /* 目的能力空间的根节点的能力指针
                                           必须与WORD_SIZE相同的深度 */
                        mapping_2,      /* dest_index: 目的CSlot的能力指针；
                                           从目的能力空间的根节点开始解析 */
                        seL4_WordBits,  /* dest_index的位数，也就是解析的深度 */
                        cnode,          /* 源能力空间的根节点的能力指针 */
                        buf2_frame_cap, /* src_index: 源CSlot的能力指针;
                                           从源能力空间的根节点开始解析 */
                        seL4_WordBits,  /* src_index的位数，也就是解析的深度 */ 
                        seL4_AllRights  /* 新能力继承的权限 */
                        );
ZF_LOGF_IFERR(error, "Failed to copy cap");
/* 地址映射 */
error = seL4_ARCH_Page_Map( mapping_2, 
                            producer_2_vspace, 
                            BUF_VADDR, 
                            seL4_AllRights, 
                            seL4_ARCH_Default_VMAttributes);
ZF_LOGF_IFERR(error, "Failed to map frame");
```

Whether this is successful will be visible after the next exercise when the consumers access their buffers. If the shared page setup for producer 2 is not correct, it will fail with a vm fault.

#### 5.2 发送信号给生产者

到这个时点，两个生产者都阻塞在`empty`通知对象上，等待共享内存准备好可以写的通知。

练习：通过`buf1_empty`和`buf2_empty`通知对象发送信号给生产者，告知其已准备好。

```c
// TODO: 通知2个生产者开始工作
seL4_Signal(buf1_empty);
seL4_Signal(buf2_empty);
```

#### 5.3 如何区分信号

现在，我们看到下面的输出内容：

```
Booting all finished, dropped to user space
Waiting for producer
2: produce
1: produce
Got badge: 2
Got badge: 1
```
At this point, the consumer should consume data from the appropriate buffer(s) and signal to the appropriate consumer(s) that the buffer is empty again. The capability to the full notification object has already been badged: producer_1s copy has a badge of 0b1 and producer_2 a badge of 0b10. By checking the bits in the badge, you can see which of the producers (it may be both) has produced data.

练习：检查badge，发送空通知给生产者。判断的方法，就是根据badge中对应的位。

```c
    // TODO, use the badge to check which producer has signalled you, and signal it back. Note that you 
    // may recieve more than 1 signal at a time.
// TODO: 使用badge检查是哪个生产者给消费者发信号，然后给其回信号。
//       注意：一次可能接收到不止一个信号。

```

At this point, you should see signals from both producers being processed, and the final Success! message printed.

## 6 高级练习

That’s all for the detailed content of this tutorial. Below we list other ideas for exercises you can try, to become more familiar with IPC.

* Create a counting semaphore implementation using notification objects.
* Create a bounded-buffer producer consumer with a buffer size greater than 1.
[TOC]

本教程对`seL4`微内核的`能力（capability）`概念有一个基本的介绍。

## 1 前提条件

1. [建立虚拟开发环境](https://docs.sel4.systems/HostDependencies)。
2. 学习完[Hello world](https://docs.sel4.systems/Tutorials/hello-world)教程。

## 2 初始化课程环境

```
# 获取课程源代码的方法，请参考https://docs.sel4.systems/Tutorials/#get-the-code
#
# 获取课程的初始化构建目录
./init --tut capabilities
# # 进入练习的目录，进行编译
cd capabilities_build
ninja
```

## 3 学习目标

通过本课程的学习，应该掌握：

1. 术语`CNode-能力节点`、`CSpace-能力空间`, `CSlot-能力槽`；
2. 知道怎样调用一个`能力`；
3. 知道怎样删除和拷贝`能力槽`。

## 4 背景知识

#### 4.1 什么是能力（capability）？

能力是授予处理器权限以允许访问系统中的实体或对象的唯一且不可伪造的令牌。`seL4`微内核能够控制的所有资源，在初始化阶段，都会交给`root`任务。如果想要改变任何资源的状态，用户可以使用内核API（包含在`libsel4`库中），去请求对某个能力的操作。

比如，`root`任务提供了一种指向它自身的线程控制块（TCB）的能力，`seL4_CapInitThreadTCB`，是在`libsel4`中定义的一个常量。想要改变`root`任务的TCB的属性，可以使用TCB相关的APIs对这个能力进行对应的操作。下面是改变`root`任务的TCB中的堆栈指针的示例，如果想要更大的堆栈空间时，需要这种操作：

```c
    seL4_UserContext registers;
    seL4_Word num_registers = sizeof(seL4_UserContext)/sizeof(seL4_Word);
    
    /* Read the registers of the TCB that the capability in seL4_CapInitThreadTCB grants access to. */
    seL4_Error error = seL4_TCB_ReadRegisters(seL4_CapInitThreadTCB, 0, 0, num_registers, &registers);
    assert(error == seL4_NoError);
    
    /* 设置新寄存器 */
    registers.sp = new_sp;      // 新的堆栈指针，派生在之前的代码
    
    /* 写新值 */
    error = seL4_TCB_WriteRegisters(seL4_CapInitThreadTCB, 0, 0, num_registers, registers);
    assert(error == seL4_NoError);
```

更多任务块读写寄存器的方式，请参考[TCB_ReadRegisters](https://docs.sel4.systems/ApiDoc.html#read-registers) and [TCB_WriteRegisters](https://docs.sel4.systems/ApiDoc.html#write-registers).

#### 4.2 什么是能力节点（CNode）？

能力节点`CNode`是一个充满能力的对象：你可以把`CNode`想象成为一个数组，数组的每个元素都是一个能力。数组的每个位置我们称之为插槽，也就是能力槽`CSlot`。在上面的示例中，`seL4_CapInitThreadTCB`就是`root`任务中的一个能力槽，其中包含指向`root`任务TCB的能力。`CNode`中的每一个`CSlot`，可以有两种状态：

* 空：`CNode`的能力槽中，包含一个null能力；
* 满：能力槽中包含一个指向内核资源的能力。

约定俗成，第0个能力槽保持为空。与进程虚拟地址空间中，保持0（NULL）地址不映射的原因相同：避免无意中使用未初始化的能力槽时出现错误。

能力槽的大小是`1u << seL4_SlotBits`。所以，能力节点中的能力槽数量可以由下面的公式进行计算得到：

    CNodeSize / (1u << seL4_SlotBits)

#### 4.3 能力空间

能力空间`CSpace`是一个线程可以访问的所有能力范围，可以由一个或多个能力节点组成。本教程中，我们重点关注`root`任务的能力空间，它是由`seL4`初始化的协议规定的，由一个能力节点（`CNode`）组成。

#### 4.4 能力空间寻址

为了能够引用能力，并对其进行操作，首先得能够对其进行寻址。`seL4`微内核提供了2种方法对能力进行寻址。一种方法是通过调用，另一种方法就是直接寻址。调用就是像上面我们操作`root`任务的`TCB`块那样，后面我们会详细解释。

###### 4.4.1 调用

一旦启动，`root`任务就会具有一个`root`能力空间。调用（`invocation`）就是通过隐式调用线程的`root`能力空间寻址能力槽（`CSlot`）。在上面的示例代码中，我们通过对`seL4_CapInitThreadTCB`能力槽的调用，读写该槽中包含的能力所指向的TCB块中的寄存器。

```c
seL4_TCB_WriteRegisters(seL4_CapInitThreadTCB, 0, 0, num_registers, registers);
```
这种方法隐式地遍历了调用线程的`root`能力空间中的`seL4_CapInitThreadTCB`能力槽，而此处的`root`能力空间就是`root`任务。

###### 4.4.2 直接能力空间寻址

直接寻址允许指定要访问的能力节点（`CNode`），而不是隐含地使用`root`能力空间。这种方式常常用来构造和操作能力空间。值得注意的是，直接寻址要求调用必须满足：通过调用CNode能力进行操作，CNode能力本身可以通过`root`能力空间进行索引。

直接寻址时需要的参数：

* `_service/root`：指向要操作的CNode能力；
* `index`：要寻址的CNode中的能力槽的索引；
* `depth`：为了寻址某个能力槽，遍历CNode的深度。初始化阶段，单层能力空间，`depth`的值总是`seL4_WordBits`。对于调用，隐含地`depth`都是等于`seL4_WordBits`。关于能力空间的深度问题，我们后续再深入讨论。

下面的示例代码中，我们直接寻址`root`任务的TCB块，拷贝其`root`能力空间中的第0个能力槽。能力节点的拷贝要求两个能力槽直接寻址：目标能力槽和源能力槽。现在我们的拷贝动作是在同一个CNode（`seL4_CapInitThreadCNode`）中进行的，该能力节点是`seL4`专门用来存放指向`root`任务的`root`能力空间的能力的能力槽。

```c
seL4_Error error = seL4_CNode_Copy(seL4_CapInitThreadCNode, 0, seL4_WordBits,
                                   seL4_CapInitThreadCNode, seL4_CapInitThreadTCB, seL4_WordBits, 
                                   seL4_AllRights);
assert(error == seL4_NoError);
```
所有的[CNode调用](https://docs.sel4.systems/ApiDoc.html#sel4_cnode)，要求直接能力寻址。

#### 4.5 初始能力空间

`root`任务肯定具有一个`root`能力空间，由`seL4`在启动阶段建立，其包含由`seL4`管理的所有资源的能力。前面我们已经见证了几个能力：`seL4_CapInitThreadTCB`和`seL4_CapInitThreadCNode`。这些都是在`libsel4`中指定的常量，但是并不是所有的初始能力都是静态指定的。也有些能力是在`libsel4`中进行了描述，由`seL4`微内核进行初始化，这些能力包含在结构体`seL4_BootInfo`中。`seL4_BootInfo`描述了初始能力的范围，包括初始能力空间中可用的自由能力槽的数量。

## 5 练习

本教程的初始代码提供给了`BootInfo`数据结构，并计算初始CNode对象的大小，单位是字节。

```c
int main(int argc, char *argv[]) {

    /* 从环境变量中解析seL4_BootInfo数据结构的位置，
     * 环境变量的设置默认在crt0.S文件中
     */
    seL4_BootInfo *info = platsupport_get_bootinfo();

    size_t initial_cnode_object_size = BIT(info->initThreadCNodeSizeBits);
    printf("Initial CNode is %zu slots in size\n", initial_cnode_object_size);
```

如果此时编译运行程序，会得到如下所示的结果：

```
Booting all finished, dropped to user space
Initial CNode is 65536 slots in size
The CSpace has 0 CSlots
<<seL4(CPU 0) [decodeInvocation/633 T0xffffff801fe08400 "rootserver" @4013c2]: >
main@main.c:32 [Cond failed: error]
    Failed to set priority
```

第一行的内容是内核打印的，第二行的内容是`printf`语句打印的初始CNode的能力槽数量，第三行声明能力空间的能力槽数量为0，这是不正确的。我们下面的任务就是修正它。

#### 5.1 如何计算能力空间

参考前面的内容，计算初始化线程的能力空间中的能力槽数量：

```c
size_t num_initial_cnode_slots = initial_cnode_object_size; // TODO calculate this.
size_t num_initial_cnode_slots = initial_cnode_object_size / (1u << seL4_SlotBits); // TODO: 计算能力槽数量
printf("The CSpace has %zu CSlots\n", num_initial_cnode_slots);
```

#### 5.2 如何在能力槽之间拷贝能力

这时候运行还会出现下面的错误：

```
The CSpace has 2048 CSlots
<<seL4(CPU 0) [decodeInvocation/633 T0xffffff801fe08400 "rootserver" @4013c2]: >
main@main.c:32 [Cond failed: error]
    Failed to set priority
```

出现上面的错误是，因为设置任务优先级的时候，操作能力空间中的最后一个能力槽。但是，此时最后一个能力槽中还没有能力占据呢！so，肯定会报错了。

接下来，我们将`root`任务的TCB能力拷贝到最后一个能力槽中。代码如下所示：

```c
seL4_CPtr first_free_slot = info->empty.start;
seL4_Error error = seL4_CNode_Copy(seL4_CapInitThreadCNode, first_free_slot, seL4_WordBits,
                                   seL4_CapInitThreadCNode, seL4_CapInitThreadTCB, seL4_WordBits,
                                   seL4_AllRights);
ZF_LOGF_IF(error, "Failed to copy cap!");
seL4_CPtr last_slot = info->empty.end - 1;
/* TODO: 使用seL4_CNode_Copy拷贝初始化TCB能力到能力空间的最后一个槽中 */
seL4_Error error = seL4_CNode_Copy(seL4_CapInitThreadCNode, last_slot, seL4_WordBits,
                                   seL4_CapInitThreadCNode, seL4_CapInitThreadTCB, seL4_WordBits,
                                   seL4_AllRights);
ZF_LOGF_IF(error, "Failed to copy cap!");
/* 设置root任务的优先级 */
error = seL4_TCB_SetPriority(last_slot, last_slot, 10);
ZF_LOGF_IF(error, "Failed to set priority");
```
编译运行，我们会看到如下所示的结果：

```
Initial CNode is 65536 slots in size
The CSpace has 2048 CSlots
<<seL4(CPU 0) [decodeCNodeInvocation/95 T0xffffff801fe08400 "rootserver" @4013c>
main@main.c:43 [Cond failed: error != seL4_FailedLookup]
    first_free_slot is not empty
```

#### 5.3 如何删除能力

练习任务中，提供的代码是要检查`first_free_slot`和`last_slot`是否为空。条件当然为假了，因为我们刚刚拷贝了能力到这两个槽中。检查能力槽是否为空，可以使用一个巧妙的方法，移动能力槽到自身。如果源能力槽为空，则会报`seL4_FailedLookup`的错误码，如果不为空，则报`seL4_DeleteFirst`。

练习：删除TCB能力的两份拷贝。代码参考如下：

```c
// TODO: 删除创建的能力
seL4_CNode_Delete(seL4_CapInitThreadCNode, first_free_slot, seL4_WordBits);
seL4_CNode_Delete(seL4_CapInitThreadCNode, last_slot, seL4_WordBits);

// 检查first_free_slot是否为空
error = seL4_CNode_Move(seL4_CapInitThreadCNode, first_free_slot, seL4_WordBits,
                        seL4_CapInitThreadCNode, first_free_slot, seL4_WordBits);
ZF_LOGF_IF(error != seL4_FailedLookup, "first_free_slot is not empty");

// 检查last_slot是否为空
error = seL4_CNode_Move(seL4_CapInitThreadCNode, last_slot, seL4_WordBits,
                        seL4_CapInitThreadCNode, last_slot, seL4_WordBits);
ZF_LOGF_IF(error != seL4_FailedLookup, "last_slot is not empty");
```

编译运行：

```
Initial CNode is 65536 slots in size
The CSpace has 2048 CSlots
<<seL4(CPU 0) [decodeCNodeInvocation/107 T0xffffff801fe08400 "rootserver" @4013>
<<seL4(CPU 0) [decodeCNodeInvocation/107 T0xffffff801fe08400 "rootserver" @4013>
Suspending current thread
main@main.c:64 Failed to suspend current thread
```

###### 5.3.1 调用能力

练习：尝试使用`seL4_TCB_Suspend`挂起当前线程：

```c
printf("Suspending current thread\n");
// TODO: 挂起当前线程
error = seL4_TCB_Suspend(seL4_CapInitThreadTCB);
ZF_LOGF_IF(error, "Failed to suspend current thread\n");
```
编译运行，结果如下：

```
Initial CNode is 65536 slots in size
The CSpace has 2048 CSlots
<<seL4(CPU 0) [decodeCNodeInvocation/107 T0xffffff801fe08400 "rootserver" @4013>
<<seL4(CPU 0) [decodeCNodeInvocation/107 T0xffffff801fe08400 "rootserver" @4013>
Suspending current thread
```

#### 5.4 高级练习

推荐一些其它的练习，巩固能力空间的掌握情况：

1. 使用一个数据结构追踪能力空间中哪些能力槽是自由的；
2. 拷贝`seL4_BootInfo`中描述的整个能力空间；
3. 实验其它的CNode调用。

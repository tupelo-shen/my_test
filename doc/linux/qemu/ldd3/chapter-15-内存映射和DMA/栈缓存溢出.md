<h1 id="0">0 目录</h1>

* [1 利用栈缓存溢出](#1)
* [2 平台间的差异](#2)
    - [2.1 栈向上增长](#2.1)
* [3 保护机制](#3)
    - [3.1 栈金丝雀](#3.1)
    - [3.2 不可执行的栈](#3.2)
    - [3.3 随机化内存地址](#3.3)

---

在软件程序中，如果对一个固定长度的目标数据结构进行写操作时，如果超出了其长度，就会写入程序所调用的栈中的相邻内存地址区域中。这就发生了栈溢出（*stack buffer overflow*）。这会导致被覆盖的内存区域中的数据损坏，从而导致程序崩溃或运行不正常。相比堆上的缓存溢出，栈缓存溢出更有可能破坏程序的执行。因为栈内包含函数的返回地址，这个地址是有效的函数指针，可以被修改执行。

作为攻击的一部分，故意造成栈缓存溢出就是 *栈溢出攻击* 。如果被攻击的程序正在以特权等级运行，或者接受不受信任的网络主机的数据，那么这个bug就是一个潜在的风险。如果，栈缓存被不受信任的用户填充数据，它们就可以在正在执行的程序内嵌入自己的可执行代码，控制当前进程。这是攻击者未经授权访问计算机的最古老，最可靠的方法之一。

<h1 id="1">1 利用栈缓存溢出</h1>

利用栈缓存溢出的常规方法就是使用一个指针覆盖掉函数的返回地址，该指针指向攻击者所使用的数据（也就是攻击者可以为所欲为了）。在下面的例子中，使用 *strcpy()* 函数进行阐述：

    #include <string.h>

    void foo (char *bar)
    {
       char  c[12];

       strcpy(c, bar);  // 没有边界检查
    }

    int main (int argc, char **argv)
    {
       foo(argv[1]);

       return 0;
    }

这段代码从命令行接受一个实参，并将其拷贝到栈上的局部变量 *c* 里。从B图中我们可以看出，如果命令行参数传递的字符个数少于12个时程序运行良好。但一旦命令行参数大于12个字符时，就会发生栈损坏。（C语言中字符串使用 *'\0'* 作为结束符）。

函数 *foo()* 在几种不同的输入命令行参数下的栈分布：

![Figure 15-5-1-ABC](https://raw.githubusercontent.com/tupelo-shen/my_test/master/doc/linux/qemu/Linux_device_drivers_3_images/15-5-1-ABC.PNG)

注意在上面的图C中，当在命令行上提供大于11字节的参数时，foo（）会覆盖本地堆栈数据，保存的帧指针，最重要的是，函数的返回地址。 当foo（）返回时，它会从堆栈中弹出返回地址并跳转到该地址（即从该地址开始执行指令）。 因此，攻击者用指向堆栈缓冲区 *char c [12]* 的指针覆盖了返回地址，该指针现在包含攻击者提供的数据。 在实际的堆栈缓冲区溢出漏洞中，“A”字符串将改为适合于平台和所需函数的shellcode。 如果此程序具有特殊权限（例如，SUID位设置为以超级用户身份运行），则攻击者可以使用此漏洞在受影响的计算机上获得超级用户权限。[3]

攻击者可以可用这些错误修改内部变量值，看下面这个例子：

    #include <string.h>
    #include <stdio.h>

    void foo (char *bar)
    {
       float My_Float = 10.5; // 假设 Addr = 0x0023FF4C
       char  c[28];           // 假设 Addr = 0x0023FF30

       // 打印 10.500000
       printf("My Float value = %f\n", My_Float);

        /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            Memory map:
            @ : c 分配的内存
            # : My_Float 分配的内存

                *c                        *My_Float
             0x0023FF30                  0x0023FF4C
                 |                           |
                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@#####
            foo("my string is too long !!!!! XXXXX");

            memcpy() 将会把地址0x1010C042(小端模式)存入变量My_Float中
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

        memcpy(c, bar, strlen(bar));  // 没有边界检查

        // 将会打印 96.031372
        printf("My Float value = %f\n", My_Float);
    }

    int main (int argc, char **argv)
    {
       foo("my string is too long !!!!! \x10\x10\xc0\x42");
       return 0;
    }

<h1 id="2">2 平台间的差异</h1>

许多系统架构在调用栈的实现方面存在细微差别，这些差异会影响 *栈缓冲区溢出漏洞* 的工作方式。 某些机器架构将调用堆栈内的顶层返回地址存储在寄存器中。这意味着在稍后展开调用的栈之前，不会使用任何覆盖的返回地址。 可能影响开发技术选择的机器特定细节的另一个例子是大多数RISC型机器架构不允许对内存进行未对齐访问。结合机器操作码的固定长度，这种机器限制可能使得跳转到ESP技术几乎不可能实现（一个例外是当程序实际包含显式跳转到栈寄存器的不太可能的代码时）。

<h2 id="2.1">2.1 栈向上增长</h2>

对于 *栈缓存溢出* 这个问题，还有一种观点认为，如果使用栈向上增长的方式，（当然了，使用这种栈的架构非常少），就能够解决栈缓存溢出。因为在同一个栈帧中，发生的缓存溢出不会覆盖掉要返回的指针。但是，对这种保护机制作深入的推敲，就会发现这只是一个极其幼稚的想法。因为发生在前一个栈帧中的缓存溢出还是会覆盖掉返回指针，别有用心的人还是可以利用这个 *bug* 。例如， 上面的例子中， *foo* 的返回值没有被覆盖，但是，实际上，栈缓存溢出发生在函数 *memcpy()* 的栈帧中。在调用 *memcpy()* 函数期间，上一个栈帧中的缓冲区会发生溢出，从而覆盖掉 *memcpy()* 的返回指针。所以说，这种方式顶多就是改变了栈缓存溢出发生的细节，但是不会显著地减少可被利用的漏洞数量。 

<h1 id="3">3 保护机制</h1>

多年来，已经开发了多种完整的方案来抑制恶意代码利用栈缓冲区。通常会被分为3类：

* 检测栈缓存溢出是否发生，然后阻止返回的指令指针向恶意代码的重定向。
* 禁止执行来自没有直接检测栈缓存溢出的栈中的代码。
* 随机化分配内存地址空间，这样发现可执行代码的概率降低。


<h2 id="3.1">3.1 栈金丝雀</h2>

*栈金丝雀*，因其类似于煤矿中的金丝雀而命令，用于在恶意代码之前检测栈缓冲溢出。这种方法的原理就是，把一个小的整数值（在程序启动时随机选择）放入内存中，其位置恰好位于栈返回指针之前。大多数缓存溢出都是从低地址到高地址覆盖内存，所以，只要覆盖了栈的返回指针，那么这个“*金丝雀*”值也会被覆盖。在程序使用栈返回的指针之前，先检查这个值是否发生改变。这样，攻击者为了获得返回指令指针，被迫使用一些非传统的方法，诸如破坏栈上的其它重要变量，从而，大大增加了利用栈缓存溢出的难度。

<h2 id="3.2">3.2 不可执行的栈</h2>

另一种保护栈缓存溢出漏洞的方法就是，对栈内存强加一种不允许从栈上执行的内存策略（*W^X*，“*写XOR执行*”）。这意味着，攻击者为了执行栈上的 *溢出代码*，既要找到禁用内存中的执行保护机制的方法，又要找到方法去把它的 *溢出代码*写入到非保护的内存区上。由于大多数的桌面系统处理器在硬件上都支持非执行功能，所以这种方法变得非常流行。

While this method definitely makes the canonical approach to stack buffer overflow exploitation fail, it is not without its problems. First, it is common to find ways to store shellcode in unprotected memory regions like the heap, and so very little need change in the way of exploitation.[11]

Even if this were not so, there are other ways. The most damning is the so-called return to libc method for shellcode creation. In this attack the malicious payload will load the stack not with shellcode, but with a proper call stack so that execution is vectored to a chain of standard library calls, usually with the effect of disabling memory execute protections and allowing shellcode to run as normal.[12] This works because the execution never actually vectors to the stack itself.

A variant of return-to-libc is return-oriented programming (ROP), which sets up a series of return addresses, each of which executes a small sequence of cherry-picked machine instructions within the existing program code or system libraries, sequence which ends with a return. These so-called gadgets each accomplish some simple register manipulation or similar execution before returning, and stringing them together achieves the attacker's ends. It is even possible to use "returnless" return-oriented programming by exploiting instructions or groups of instructions that behave much like a return instruction.[13]


<h2 id="3.3">3.3 随机化内存地址</h2>

Instead of separating the code from the data, another mitigation technique is to introduce randomization to the memory space of the executing program. Since the attacker needs to determine where executable code that can be used resides, either an executable payload is provided (with an executable stack) or one is constructed using code reuse such as in ret2libc or return-oriented programming (ROP). Randomizing the memory layout will, as a concept, prevent the attacker from knowing where any code is. However, implementations typically will not randomize everything; usually the executable itself is loaded at a fixed address and hence even when ASLR (address space layout randomization) is combined with a nonexecutable stack the attacker can use this fixed region of memory. Therefore, all programs should be compiled with PIE (position-independent executables) such that even this region of memory is randomized. The entropy of the randomization is different from implementation to implementation and a low enough entropy can in itself be a problem in terms of brute forcing the memory space that is randomized.

不是将代码与数据分开，另一种缓解技术是将随机化引入执行程序的存储空间。由于攻击者需要确定可以使用的可执行代码所在的位置，因此可以提供可执行的有效负载（使用可执行堆栈），或者使用代码重用来构造一个，例如在ret2libc或面向返回的编程（ROP）中。作为一个概念，随机化内存布局将防止攻击者知道任何代码的位置。但是，实现通常不会随机化所有内容;通常，可执行文件本身是在固定地址加载的，因此即使ASLR（地址空间布局随机化）与不可执行的堆栈组合，攻击者也可以使用这个固定的内存区域。因此，所有程序都应该用PIE（与位置无关的可执行文件）进行编译，这样即使这个内存区域也是随机的。随机化的熵与实现不同，并且足够低的熵本身就是强制随机化的存储空间的问题。

<div style="text-align: right"><a href="#0">回到顶部</a><a name="_label0"></a></div>
* [10.1 I/O 端口和 I/O 内存](#10.1 )
    - [10.1.1 I/O寄存器和通用内存](#10.1.1 )
* [10.2 使用 I/O 端口](#10.2 )
    * [10.2.1 申请I/O端口](#10.2.1 )
    * [10.2.2 读写I/O端口](#10.2.2 )
    * [10.2.3 从用户空间访问I/O端口](#10.2.3 )
    * [10.2.4 连续操作](#10.2.4 )
    * [10.2.5 延时访问I/O ](#10.2.5 )
    * [10.2.6 平台依赖 ](#10.2.6 )
* [10.3 一个I/O端口例子](#10.3 )
    * [10.3.1 并口概述](#10.3.1 )
    * [10.3.2 示例驱动程序](#10.3.2 )
* [10.4 使用I/O内存](#10.4 )
    * [10.4.1 I/O内存分配和映射](#10.4.1 )
    * [10.4.2 访问I/O内存](#10.4.2 )
    * [10.4.3 端口模拟为I/O内存](#10.4.3 )
    * [10.4.4 为I/O重用short](#10.4.4 )
    * [10.4.5 ISA Memory Below 1 MB ](#10.4.5 )
    * [10.4.6 isa_readb及其辅助函数 ](#10.4.6 )

***

Although some devices can be controlled using nothing but their I/O regions, most real devices are a bit more complicated than that. Devices have to deal with the external world, which often includes things such as spinning disks, moving tape, wires to distant places, and so on. Much has to be done in a time frame that is different from, and far slower than, that of the processor. Since it is almost always undesirable to have the processor wait on external events, there must be a way for a device to let the processor know when something has happened.

That way, of course, is interrupts. An interrupt is simply a signal that the hardware can send when it wants the processor’s attention. Linux handles interrupts in much the same way that it handles signals in user space. For the most part, a driver need only register a handler for its device’s interrupts, and handle them properly when they arrive. Of course, underneath that simple picture there is some complexity; in particular, interrupt handlers are somewhat limited in the actions they can perform as a result of how they are run.
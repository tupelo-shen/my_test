
###动态内存管理
***

内存管理的目标是提供一种方法，为实现各种目的而在各个用户之间实现内存共享。内存管理方法应该实现以下两个功能：

1. 最小化管理内存所需的时间
2. 最大化用于一般应用的可用内存（最小化管理开销）

内存管理实际上是一种关于权衡的零和游戏。您可以开发一种使用少量内存进行管理的算法，但是要花费更多时间来管理可用内存。也可以开发一个算法来有效地管理内存，但却要使用更多的内存。最终，特定应用程序的需求将促使对这种权衡作出选择。

每个内存管理器都使用了一种基于堆的分配策略。在这种方法中，大块内存（称为 堆）用来为用户定义的目标提供内存。当用户需要一块内存时，就请求给自己分配一定大小的内存。堆管理器会查看可用内存的情况（使用特定算法）并返回一块内存。搜索过程中使用的一些算法有 `first-fit`（在堆中搜索到的第一个满足请求的内存块 ）和 `best-fit`（使用堆中满足请求的最合适的内存块）。当用户使用完内存后，就将内存返回给堆。

这种基于堆的分配策略的根本问题是碎片（`fragmentation`）。当内存块被分配后，它们会以不同的顺序在不同的时间返回。这样会在堆中留下一些洞，需要花一些时间才能有效地管理空闲内存。这种算法通常具有较高的内存使用效率（分配需要的内存），但是却需要花费更多时间来对堆进行管理。

另外一种方法称为伙伴关系分配策略 `buddy memory allocation`，是一种更快的内存分配技术，它将内存划分为`2`的幂次方个块链表，如每个块链表分别包含大小为1，2，4，8，16，32，64，128，256，512和1024个连续页框的页框块。最大可以申请1024个连续页框，对应4MB大小的连续内存。并使用`best-fit`方法来分配内存请求。

假设要申请一个256个页框的块，先从256个页框的链表中查找空闲块，如果没有，就去512个页框的链表中找，找到了则将页框块分为2个256个页框的块，一个分配给应用，另外一个移到256个页框的链表中。如果512个页框的链表中仍没有空闲块，继续向1024个页框的链表查找，如果仍然没有，则返回错误。

当用户释放内存时，就会检查`buddy`块，查看其相邻的内存块是否也已经被释放。如果是的话，将合并内存块以最小化内存碎片。这个算法的时间效率更高，但是由于使用`best-fit`方法的缘故，会产生内存浪费。

###slab 缓存
***

Linux 所使用的 slab 分配器的基础是 Jeff Bonwick 为 SunOS 操作系统首次引入的一种算法。Jeff 的分配器是围绕对象缓存进行的。在内核中，会为有限的对象集（例如文件描述符和其他常见结构）分配大量内存。Jeff 发现对内核中普通对象进行初始化所需的时间超过了对其进行分配和释放所需的时间。因此他的结论是不应该将内存释放回一个全局的内存池，而是将内存保持为针对特定目而初始化的状态。例如，如果内存被分配给了一个互斥锁，那么只需在为互斥锁首次分配内存时执行一次互斥锁初始化函数（mutex_init）即可。后续的内存分配不需要执行这个初始化函数，因为从上次释放和调用析构之后，它已经处于所需的状态中了。

Linux slab 分配器使用了这种思想和其他一些思想来构建一个在空间和时间上都具有高效性的内存分配器。

图 1 给出了 slab 结构的高层组织结构。在最高层是 cache_chain，这是一个 slab 缓存的链接列表。这对于 best-fit 算法非常有用，可以用来查找最适合所需要的分配大小的缓存（遍历列表）。cache_chain 的每个元素都是一个 kmem_cache 结构的引用（称为一个 cache）。它定义了一个要管理的给定大小的对象池。

图 1. slab 分配器的主要结构

![slab](D:\Works_YOKOGAWA\git_repository\test_github_repository\my_test\doc\linux\qemu\Linux_device_drivers_3_images\slab.gif)


(https://github.com/tupelo-shen/my_test/blob/master/doc/linux/qemu/Linux_device_drivers_3_images/slab%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%84.gif)

(D:\Works_YOKOGAWA\git_repository\test_github_repository\my_test\doc\linux\qemu\ldd3\chapter8-allocating memory\slab.gif)

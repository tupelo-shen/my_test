<h1 id="0">0 目录</h1>

* [2.1 建立测试系统](#2.1)
* [2.2 Hello World](#2.2)
* [2.3 内核模块和应用程序](#2.3)
    - [2.3.1 用户空间和内核空间](#2.3.1)
    - [2.3.2 内核中的并发处理](#2.3.2)
    - [2.3.3 当前进程](#2.3.3)
    - [2.3.4 其它细节](#2.3.4)
* [2.4 编译和加载](#2.4)
    - [2.4.1 编译模块](#2.4.1)
    - [2.4.2 加载和卸载模块](#2.4.2)


本章介绍了关于模块和内核编程的一些基本概念。通过构建并运行一个完整的模块，查看所有模块所共有的一些基本代码。为了避免一次引出太多的概念，本章只讲解模块，而不涉及任何特定的设备。

<h2 id="2.1">2.1 建立测试系统</h2>

从本章开始，开始使用例子验证一些编程概念。（所有的例子，在O’Reilly’s FTP网站上都能找到）构建，加载，和修改这些例子，都是增加对驱动程序的工作原理及如何与内核交互的理解。

示例模块应该可以与任何一种2.6.x内核一起使用，包括由发行商提供的发行版内核。但是，我们建议您直接从kernel.org镜像网络获取“主线”内核，并将其安装到您的系统上。发行商提供的内核与“主线” 内核有着很大差异，因为其往往打了大量的补丁文件；有时，发行商的补丁程序可能更改设备驱动程序所看到的内核API。如果你正在编写一个必须适用于特定发行版的驱动程序，那么你一定会想要针对相关的内核进行构建和测试。但是，为了学习驱动程序写作的目的，标准内核是最好的。

无论您的内核的来源如何，为2.6.x构建模块都要求您在系统上配置并构建内核树。这个要求与以前的内核版本发生改变，其中当前的头文件集是足够的。将2.6内核的模块链接到内核源代码树中找到的目标文件；结果是一个更强大的模块加载器，但也要求这些目标文件可用。因此，您的第一步是创建一个内核源代码树（来自kernel.org网络或您的经销商的内核源代码包），构建一个新的内核并将其安装到您的系统上。由于我们稍后会看到的原因，如果在构建模块时实际运行目标内核，通常是最简单的，但这不是必需的。

> 注意：最好准备一个测试系统。

<h2 id="2.2">2.2 Hello World</h2>

无处不在的“*Hello World*”。代码内容如下：

    #include <linux/init.h>
    #include <linux/module.h>

    MODULE_LICENSE("Dual BSD/GPL");
    static int hello_init(void)
    {
        printk(KERN_ALERT "Hello, world\n");
        return 0;
    }
    static void hello_exit(void)
    {
        printk(KERN_ALERT "Goodbye, cruel world\n");
    }
    module_init(hello_init);
    module_exit(hello_exit);

这个模块定义了2个函数，一个是当模块被加载时调用的函数（*hello_init*）；还有一个是卸载模块时调用的函数(*hello_exit*)。*module_init* 和 *module_exit* 使用特定的内核宏表明这两个函数的职责。另外一个宏 *MODULE_LICENSE* 用来告诉内核，该模块使用的许可证。
*printk* 函数类似于C标准库中的 *printf* 函数。为什么模块能够调用内核的 *printk* 函数？那是因为模块被使用 *insmod* 命令加载进入内核后，模块就会被连接到内核，可以访问内核的公共符号（函数和变量）。*KERN_ALERT* 是消息的优先级。
你可以使用 **insmod** 和 **rmmod** 命令加载、卸载模块程序，注意的是，只有root用户具有加载、卸载的权限。

    % make
    make[1]: Entering directory `/usr/src/linux-2.6.10'
     CC [M] /home/ldd3/src/misc-modules/hello.o
     Building modules, stage 2.
     MODPOST
     CC /home/ldd3/src/misc-modules/hello.mod.o
     LD [M] /home/ldd3/src/misc-modules/hello.ko
    make[1]: Leaving directory `/usr/src/linux-2.6.10'
    % su
    root# insmod ./hello.ko
    Hello, world
    root# rmmod hello
    Goodby cruel world
    root#

请再次注意，上述步骤能够正常执行，您必须在makefile能够找到它的地方有正确配置和构建的内核树（在本例中为 */usr/src/linux-2.6.10*）。 我们将在“2.4编译和加载”一节中详细介绍如何构建模块。

其实编写一个可以运行的模块并不是什么难事，难点在于如何了解设备及如何最大限度的提供性能。

<h2 id="2.3">2.3 内核模块和应用程序</h2>

在我们继续深入之前，必须强调一下内核模块和应用程序之间的各种差异。

大部分的中小型应用程序从头到尾都在执行一个简单的任务，而内核模块仅仅是为了后面的请求而注册自己，初始化函数在注册完成后立即终止。换句话说，模块初始化函数的任务是为稍后调用模块的函数做准备;就好像这个模块在说“我在这里，而这正是我所能做到的。”模块的exit函数（示例中为hello_exit）在模块卸载之前被调用。它应该告诉内核，“我不在那里了，不要再要求我做其它任何事情。”这种编程方法与事件驱动编程类似，但并非所有的应用程序都是事件驱动的，但每个内核模块都是。事件驱动的应用程序和内核代码之间的另一个主要区别在于exit函数：即将终止的应用程序可能懒惰地释放资源或者避免完全清理，模块的exit函数必须小心地撤消init函数所构建的所有内容，或者系统重启前一直存在的碎片。

顺便提一句，卸载模块是最应该欣赏的模块化特性之一，因为它有助于缩短开发时间；你可以测试新驱动程序的后续版本，而无需每次都经历漫长的关机/重启周期。

作为程序员，你知道应用程序可以调用它没有定义的函数：链接阶段使用适当的函数库来解析外部引用。printf是这些可调用函数之一，并在libc中定义。另一方面，模块只与内核链接，它可以调用的唯一函数是内核导出的函数；没有可链接的库。例如，早先在hello.c中使用的printk函数是在内核中定义并导出到模块的printf版本。它的行为与原始函数类似，但有一些细微差别，主要原因是缺少浮点支持。

图2-1显示了在模块中如何使用函数调用和函数指针向正在运行的内核添加新功能。

![Figure 2-1](https://raw.githubusercontent.com/tupelo-shen/my_test/master/doc/linux/qemu/Linux_device_drivers_3_images/2-1.PNG)

因为内核模块不需要链接标准库文件，所以源文件中不会包含通用的头文件。当然了，<stdarg.h>和其它一些特殊情况除外。实际上，内核模块只使用本身就是内核一部分的那些函数。大多数相关的头文件都存在于目录 *include/linux* 和 *include/asm* 下。*include*目录下的其它子目录包含与特定内核相关的一些头文件。

本书中，在引入每个头文件的时候，都会分别介绍这些头文件的作用。

内核编程和应用编程之间的另一个重要区别在于如何处理故障：在应用程序开发过程中出现 *segmentation fault* 没有什么大不了的，因为我们可以使用调试器跟踪源代码的错误去定位问题；然而，*kernel fault*不仅可以杀死当前的进程，甚至可以杀死整个系统。这部分的详细内容我们将会在第4章介绍。

<h3 id="2.3.1">2.3.1 用户空间和内核空间</h3>

*module*在内核空间运行，而应用程序在用户空间运行。这个概念是操作系统理论的基础。

实际上，操作系统的作用是提供与计算机硬件一致的程序。 另外，操作系统必须考虑程序的独立操作并防止未经授权访问资源。只有当CPU强制从应用程序中保护系统软件时，才可能执行这项重要的任务。

每个现代处理器都能够执行这种行为。所选择的方法是在CPU本身中实现不同的操作模式（或等级）。各等级具有不同的角色，并且一些操作在较低级别上被禁止；程序代码只能通过有限数量的通道来从一个层切换到另一个层。Unix系统旨在利用这种硬件功能，使用两个这样的等级。目前所有的处理器至少有2个保护级别，而一些像x86系列的处理器有更多的级别;当存在多个级别时，使用最高级别和最低级别。在Unix下，内核以最高级别（也称为超级用户模式）执行，其中允许所有内容，而应用程序以最低级别（所谓的用户模式）执行，其中处理器管理对硬件的直接访问和对内存的非授权访问。

我们通常将执行模式称为内核空间和用户空间。这些术语不仅包含两种模式固有的不同特权级别，还包含每种模式都可以有自己的内存映射-它自己的地址空间的事实。

每当应用程序发出系统调用或被硬件中断挂起时，Unix都会将执行从用户空间转移到内核空间。执行系统调用的内核代码在进程的上下文中工作，它代表调用进程运行，并能够访问进程地址空间中的数据。另一方面，处理中断的代码与进程不同步，并且与任何特定进程无关。

模块的作用是扩展内核功能；模块化代码在内核空间中运行。通常，驱动程序会执行前面概述的任务：模块中的某些功能是作为系统调用被执行，而有些功能负责中断处理。

<h3 id="2.3.2">2.3.2 内核中的并发处理</h3>

内核编程和传统应用编程大不相同的地方在于并发性问题的处理。大多数应用程序（不包括多线程应用程序），一般来说，都是从头到尾顺序执行，不用担心并发性问题。而内核代码就不能假设这样理想的执行环境，即便最简单的驱动模块代码也必须考虑多种情况可能同时发生。

内核编程中有几个并发的来源。当然，Linux系统运行了多个进程，其中，可能不止一个进程尝试调用你的驱动程序。大多数设备能够中断处理器，中断处理程序是异步执行，可以同时和你的驱动程序并行调用。其次，一些软件抽象（比如后面介绍的内核定时器）也是异步执行的。此外，Linux也可以运行在对称多处理器（SMP）系统上运行，所以，驱动程序必须可以运行在多个CPU上。最后，从Linux 2.6版本开始，内核代码是可抢占式的； 这种变化导致，即使单处理器系统也会发生如同多处理器一样的并发问题。

因此，Linux内核代码（包括驱动程序代码）必须是可重入的 - 它必须能够同时在多个环境中运行。必须仔细设计数据结构以保证多个执行线程是分离的，并且代码必须小心访问共享数据，防止数据损坏。编写处理并发性和避免竞争的代码（不确定的执行顺序可能导致不想要的行为）需要深思熟虑，且非常困难。正确的并发管理需要编写正确的内核代码；出于这个原因，本书中的每个示例驱动程序都是以并发的思想编写的。所使用的技术在我们遇到时会解释；第5章也专门讨论了这个问题以及可用于并发管理的内核原语。

驱动开发者犯的一个常见错误就是，假设只要某一代码段没有进入休眠状态（或“阻塞”状态），并发就不是问题。即使在以前的内核中（非抢先式的），这种假设在多处理器系统上是无效的。在2.6内核代码中（几乎）不会假定它可以给某一段代码保持占用处理器。如果没有并发的思维编写内核相关代码，将会面临极其难以调试的灾难性故障。

<h3 id="2.3.3">2.3.3 当前进程</h3>

尽管内核模块并不像应用程序那样按顺序执行，但内核执行的大多数操作都是代表特定进程完成的。内核代码可以通过访问 *asm/current.h*中定义的全局量current来引用当前进程，这会产生一个指向struct task_struct 的指针，在 *linux/sched.h* 中定义。current指针指的是当前正在执行的进程。在执行系统调用期间，例如open或read，当前进程是调用该系统调用的进程。如果需要的话，内核代码可以使用current访问具体进程的信息。第6章介绍了使用这种技术的一个例子。

实际上，current并不是真正的全局变量。支持SMP系统的需求迫使内核开发人员开发一种在相关的CPU上查找当前进程的机制。这种机制必须很快，因为对current的引用经常发生。其结果就是依赖于特定架构的机制，在内核的堆栈上隐藏一个结构体task_struct的指针。实现的细节对其它内核子系统仍然保持隐藏，设备驱动程序只需包含头文件 *linux/sched.h*就可以引用current进程。例如，下面的语句通过访问struct task_struct中的某些字段来打印当前进程的进程标识和命令名称：
    
    printk(KERN_INFO "The process is \"%s\" (pid %i)\n", current->comm, current->pid);

存储在 *current->comm* 中的命令名称是当前进程正在执行的程序文件的基本名称（如果需要，可以修剪为15个字符）。

<h3 id="2.3.4">2.3.4 其它细节</h3>

内核编程在很多方面与用户空间编程不同。在本书的过程中，随着逐渐接近它们，我们会尽量的指出它们，但是有一些基本问题值得一提，尽管这些问题不属于它们的一部分。因此，在深入研究内核时，应牢记以下问题。

应用程序运行在虚拟内存，具有很大的堆栈空间。堆栈用于保存函数调用历史记录和由当前活动函数创建的所有自动变量。相反，内核有一个非常小的堆栈；它小到只有4096个字节。所以，你的函数必须与整个内核空间调用链共享该堆栈。因此，声明大的自动变量绝不是一个好主意；如果你需要更大的结构，应该在调用时动态分配它们。

通常，当您查看内核API时，您将遇到以双下划线（__）开头的函数名称。如此标记的功能通常是较低层面的接口函数，应谨慎使用。本质上，就好像，双下划线对程序员说：“如果你调用这个函数，确保知道你在做什么。”

内核代码不能做浮点运算。启用浮点需要要求内核保存并恢复浮点处理器的每个入口的状态，并退出内核空间-至少在某些体系结构上是这样的。鉴于内核代码中实际上不需要浮点数，额外的开销并不值得。

<h2 id="2.4">2.4 编译和加载</h2>

内核发展到现在，其构建系统已经变得非常复杂，好在现在有好些项目帮我们完成内核程序的构建。对于想要深入了解内核构建系统的人，可以查看内核源代码中的 *Documentation/kbuild* 目录下的文件。

<h3 id="2.4.1">2.4.1 编译模块</h3>

在[2.2 Hello World](#2.2)一章中，我们已经给出了hello World的源代码，那么如果要编译这段代码为内核可执行模块，我们就必须写一个 *Makefile* ，用其指定编译环境，编译工具，生成依赖文件，目标文件等等。

对于Hello World这个程序来说，其Makefile非常简单：

    obj-m := hello.o

但是看到这里，会有人问，“这与我们平时看见的Makefile文件不一样啊？”这是因为构建系统为你完成了剩余的工作。

那么当有多个源文件的时候，如何编译生成一个模块文件？比如说有 *file1.c* 和 *file2.c* 两个源文件，生成 *module.ko* 的模块，那正确的写法就是：

    obj-m := module.o
    module-objs := file1.o file2.o

上面这样写的 *Makefile* 必须放在构建系统里。比如说，你的内核源代码位于 *~/kernel-2.6* 目录下，那么 *make* 命令如下：

    make -C ~/kernel-2.6 M=`pwd` modules

使用 *-C* 选项，指定你的内核源代码目录；在那里它会发现内核的顶层 *Makefile*。M选项，会在尝试构建 *modules*目标之前， 移回到模块源码所在目录中。 这个modules目标指的是 *obj-m* 变量中指定的模块列表，在我们的例子中，我们已经设置为 *module.o*。
这样的make命令会使得在内核源代码树之外构建模块变得更为容易。编写 *Makefile* 的诀窍如下：

    # 如果KERNELRELEASE被定义，将会使用你把hello.c源代码放入的构建系统，
    ifneq ($(KERNELRELEASE),)
        obj-m := hello.o
    # 否则，直接从获取Host主机的内核系统并使用
    else
        KERNELDIR ?= /lib/modules/$(shell uname -r)/build
        PWD := $(shell pwd)
    default:
        $(MAKE) -C $(KERNELDIR) M=$(PWD) modules
    endif

这个Makefile指定了2种编译环境，第一种情况，如果把源代码放入了目标机的内核构建系统中，则因为，一般情况下在其中的顶层Makefile中，都会定义 *KERNELRELEASE* 这个环境变量，所以代码执行if语句的第一个分支，使用指定的内核构建系统编译代码。第二种情况， 如果想直接在宿主机上编译内核模块，设置 *KERNELDIR* 环境变量，设置对应于宿主机的内核构建系统。然后，执行编译。

请注意，以上不是完整的Makefile；一个真正的Makefile包含了用于清理不需要的文件，安装模块等常用的目标。查看源代码目录中的makefile以获取完整示例。

<h3 id="2.4.2">2.4.2 加载和卸载模块</h3>

需要牢牢记住的一点就是，模块代码的内核构建系统与要运行的内核版本必须对应。因为模块中使用的数据结构和函数原型与内核版本中定义的紧密相关，内核提供的接口因版本的不同，而有着显著的变化。

内核不仅假定给定的模块是根据根据正确的内核版本构建。编译过程的一个步骤就是，将编译的模块与内核源码树中的文件（vermagic.o）相链接。这个文件包含编译模块所基于的Linux内核版本的信息，包括目标内核版本，编译器版本，许多重要的配置变量的设置。当尝试载入一个模块时，就会验证这些信息是否与正在运行的内核相同。如果发生不匹配，内核不会加载，并报下面的错误：

    # insmod hello.ko
    Error inserting './hello.ko': -1 Invalid module format

查看系统log文件（/var/log/messages或者你的系统中其它类似的配置文件）能够看到造成模块加载失败的原因。

如果您需要编译特定内核版本的模块，则需要使用该特定版本的编译系统和源代码树。之前的示例Makefile中的KERNELDIR变量的就是很好的一个方法。

内核接口经常伴随着版本发生变化。如果您正在编写一个旨在与多个内核版本一起工作的模块（特别是如果它必须在主要版本中工作），则可能必须使用宏和#ifdef结构来正确构建代码。本书的这个版本只关注内核的一个主要版本，所以你不会在我们的示例代码中看到版本测试。但是他们的需求偶尔会出现。在这种情况下，您想要使用 *linux/version.h* 中的定义。这个头文件自动包含了 *linux/module.h*，且定义了以下宏：

<div style="text-align: right"><a href="#0">回到顶部</a><a name="_label0"></a></div>

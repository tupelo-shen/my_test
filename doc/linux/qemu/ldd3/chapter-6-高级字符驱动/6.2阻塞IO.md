<h1 id="0">0 目录</h1>
* [6.2 阻塞I/O](#6.2)
    - [6.2.1 休眠的介绍](#6.2.1)
    - [6.2.2 简单休眠](#6.2.2)
    - [6.2.3 阻塞和非阻塞操作](#6.2.3)
    - [6.2.4 一个阻塞I/O例子](#6.2.4)
    - [6.2.5 高级休眠](#6.2.5)
        + [6.2.5.1 进程如何休眠](#6.2.5.1)
        + [6.2.5.2 手动休眠](#6.2.5.2)
        + [6.2.5.3 独占等待](#6.2.5.3)
        + [6.2.5.4 唤醒的细节](#6.2.5.4)
        + [6.2.5.5 旧接口](#6.2.5.5)
    - [6.2.6 测试scullpipe驱动](#6.2.6)

<h2 id="6.2">6.2 阻塞I/O</h2>

在第3章中，我们已经编写了scull设备read和write方法，但是我们忽略了一个重要的问题，如果当我们read时，scull设备还没有数据可用怎么办？当我们write时，scull设备还没准备好接收数据怎么办？在这些情况下，驱动程序默认应该阻塞进程，让其休眠直至发出的请求可以被响应。

本章展示了怎样使一个进程休眠和何时唤醒。首先，先来了解一些新概念。

<h3 id="6.2.1">6.2.1 休眠的介绍</h3>

什么是休眠？休眠就是进程被标记为特殊状态并从调度器管理的运行队列中删除。除非外界修改这种状态，否则进程就不会被任何CPU调度。

在linux设备驱动中使进程休眠是一件很简单的事情。但是，要想使代码安全的休眠，必须注意两条规则：

* 第一条规则：原子操作的上下文中不能休眠。

    在第5章我们已经了解了，原子操作是阻止并发访问的一种手段。那么也就意味着你的驱动程序持有自旋锁，seqlock，或RCU lock时，不能进行休眠。当然了，如果中断被失能，也不能进行休眠。拥有信号量可以休眠，但是必须小心。如果拥有信号量的代码休眠，那么其它等待信号量的代码也会休眠。因此，拥有信号量的代码休眠时间必须短，且你应该确信，不会阻塞那些最终会唤醒你的那些进程。

* 另一条规则就是：唤醒后不能假设系统的状态，必须检查确保等待的条件是真的。

    因为当唤醒时，肯定不会知道已经失去CPU控制权多长时间；同时，在这段时间内发生了什么。另外，你通常也不会知道是否有另一个进程也在等待同一事件而在休眠；那个进程可能在你的进程之前被唤醒同时掠夺你的进程可能在等待的资源。

当唤醒事件发生时，通知wait队列（等待某一事件的进程列表）。

在linux中，使用wait_queue_head_t结构体来管理wait队列，其定义位于头文件`<linux/wait.h>`中。其初始化的形式如下：

    DECLARE_WAIT_QUEUE_HEAD(name);

或动态初始化，

    wait_queue_head_t my_queue;
    init_waitqueue_head(&my_queue);

<h3 id="6.2.2">6.2.2 简单休眠</h3>

Linux内核中，使进程进入休眠的最简单方法，如下：

    wait_event(queue, condition)
    wait_event_interruptible(queue, condition)
    wait_event_timeout(queue, condition, timeout)
    wait_event_interruptible_timeout(queue, condition, timeout)

* queue就是wait_queue_head_t类型的队列，注意是值传递的方式。
* condition就是休眠前后通过宏计算的任意bool表达式；除非condition称为true，否则一直休眠。值得注意的是，condition是次数的任意数字，所以不能有任何副作用。

如果使用wait_event，进程将会进入不可中断的休眠中，这应该不是你想要的结果。优先选择的替代方案就是，wait_event_interruptible，它可被信号中断，返回整数值。非0，说明休眠被某一类信号中断，驱动程序就应该返回-ERESTARTSYS。wait_event_timeout和wait_event_interruptible_timeout定周期等待，如果时间到，无论condition是否满足条件，都返回0。

唤醒休眠的进程的语法是：

    void wake_up(wait_queue_head_t *queue);
    void wake_up_interruptible(wait_queue_head_t *queue);

wake_up唤醒给定队列中所有正在等待进程（当然了实际情况非常复杂，我们稍后会看到）。wake_up_interruptible只唤醒可中断休眠。通常情况下，与等待被唤醒的语句配套使用。比如wake_up和wait_event配合使用。

我们下面看一个关于休眠和唤醒的简单例子。模块我们称之为sleepy。表现行为：任何试图读取设备的进程都会进入休眠；无论什么时候有一个进程写设备，都会唤醒所有的进程。读写方法如下，所示：

    static DECLARE_WAIT_QUEUE_HEAD(wq);
    static int flag = 0;
    ssize_t sleepy_read (struct file *filp, char __user *buf, size_t count, loff_t *pos)
    {
        printk(KERN_DEBUG "process %i (%s) going to sleep\n", current->pid,
            current->comm);
        wait_event_interruptible(wq, flag != 0);
        flag = 0;
        printk(KERN_DEBUG "awoken %i (%s)\n", current->pid, current->comm);
        return 0; /* EOF */
    }
    ssize_t sleepy_write (struct file *filp, const char __user *buf, size_t count,
        loff_t *pos)
    {
        printk(KERN_DEBUG "process %i (%s) awakening the readers...\n",
        current->pid, current->comm);
        flag = 1;
        wake_up_interruptible(&wq);
        return count; /* succeed, to avoid retrial */
    }

Note the use of the flag variable in this example. Since wait_event_interruptible
checks for a condition that must become true, we use flag to create that condition.

It is interesting to consider what happens if two processes are waiting when sleepy_write
is called. Since sleepy_read resets flag to 0 once it wakes up, you might think that the
second process to wake up would immediately go back to sleep. On a single-processor
system, that is almost always what happens. But it is important to understand why you
cannot count on that behavior. The wake_up_interruptible call will cause both sleeping
processes to wake up. It is entirely possible that they will both note that flag is nonzero
before either has the opportunity to reset it. For this trivial module, this race condition is
unimportant. In a real driver, this kind of race can create rare crashes that are difficult to
diagnose. If correct operation required that exactly one process see the nonzero value, it
would have to be tested in an atomic manner. We will see how a real driver handles
such situations shortly. But first we have to cover one other topic.

<h3 id="6.2.3">6.2.3 阻塞和非阻塞操作</h3>
<h3 id="6.2.4">6.2.4 一个阻塞I/O例子</h3>
<h3 id="6.2.5">6.2.5 高级休眠</h3>

<h4 id="6.2.5.1">6.2.5.1 进程如何休眠</h4>
<h4 id="6.2.5.2">6.2.5.2 手动休眠</h4>
<h4 id="6.2.5.3">6.2.5.3 独占等待</h4>
<h4 id="6.2.5.4">6.2.5.4 唤醒的细节</h4>
<h4 id="6.2.5.5">6.2.5.5 旧接口</h4>

<h3 id="6.2.6">6.2.6 测试scullpipe驱动</h3>
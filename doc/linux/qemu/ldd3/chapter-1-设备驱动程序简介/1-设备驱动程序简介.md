<h1 id="0">0 目录</h1>

* [1.1 设备驱动的角色](#1.1)
* [1.2 划分内核](#1.2)
    - [1.2.1 可加载模块](#1.2.1)
* [1.3 设备和模块](#1.3.1)


Linux的优秀已无需赘言，但是，面对如此浩瀚的工程，我们往往无从下手。所以，为了能够理解Linux内核源代码，我们本着“先易后难”，“先外后内”的思路，逐层进行理解。而驱动程序就是我们的切入点。

设备驱动程序在Linux内核中扮演着特殊的角色。它们是一个个不同的“黑盒子”，提供了具有良好规范的内部编程接口来响应某一种特定的硬件，完全隐藏了设备工作的细节。用户行为通过一组独立于具体驱动程序的标准化调用来执行；然后，将这些调用映射到作用于真实硬件的设备具体操作上，这就是设备驱动程序的职责了。这种编程接口使得驱动程序可以与内核的核心代码，分开构建，并在需要的时候，实现运行时“插入”。这种模块化的方式，使Linux驱动程序易于编写。

本书教你如何编写自己的驱动程序，并解释涉及到内核部分的代码。我们着重讲述编程技术和接口，而不会详细研究某个具体的设备。虽然驱动程序千差万别，但是实现原理和编程技术都是一样的。

在编写驱动程序的过程中，你会发现这其中涉及到很多Linux内核的知识。这有助于我们了解机器是如何工作的，是否按照我们的期望那样工作。我们会循序渐进，逐渐引入新的概念，并用简单的实例对概念进行阐述，尽量做到深入简出。

那么，首先让我们了解一些基本的概念吧！

<h2 id="1.1">1.1 设备驱动的角色</h2>

作为一名程序员，您可以自行选择驱动程序，在编程时间和结果的灵活性之间达到某种平衡。

机制和策略之间的区别是Unix设计背后的最佳想法之一。大多数编程问题确实可以分为两部分：“要提供什么功能”（机制）和“如何使用这些功能”（策略）。如果这两个问题由程序的不同部分或者甚至完全由不同的程序解决，则软件包更容易开发且更容易适应特定需求。

例如，Unix图形显示管理分为X服务器，及窗口和会话管理器；X服务器负责感知硬件，提供给用户程序一个统一的接口；窗口和会话管理器在不知道硬件的情况下，实现了一种特定的策略。用户可以在不同的硬件上使用相同的窗口管理器，不同的用户可以在相同的工作站上运行不同的配置。即使完全不同的桌面环境，诸如KDE和GNOME，也可以在同一个系统上共存。另一个例子是TCP/IP网络的分层结构：操作系统提供套接字抽象，它不实现有关要传输的数据的策略，而不同的服务器负责服务（及其相关的策略）。进一步讲，像ftpd这样的服务器提供了文件传输机制，而用户可以使用他们喜欢的任何客户端;即使存在命令行和图形客户端，任何人也都可以编写新的用户界面来传输文件。

涉及驱动程序的地方，采取同样的机制和策略分离的思想。软盘驱动器（floppy）就是无策略的，它的作用只是将软盘显示为连续的数据块。系统的更高级别提供策略，例如谁可以访问软盘驱动器，直接访问驱动器还是通过文件系统访问，以及用户是否可以在驱动器上装入文件系统。由于不同的环境通常需要以不同的方式使用硬件，因此尽可能无策略是很重要的。

编写驱动程序时，程序员应该特别注意这个基本概念：编写内核代码来访问硬件，但不要强制用户的特定策略，因为不同的用户有不同的需求。驱动程序应该使硬件可用，关于如何使用硬件的所有问题留给应用程序。如果驱动程序在不增加约束的情况下提供对硬件功能的访问，则它是灵活的。然而有时候，一些策略还是必须的。例如，数字I/O驱动程序可能只提供字节宽度的硬件访问权限，以避免处理单个位所需的额外代码。

您也可以从不同的角度来看待您的驱动程序：它是位于应用程序和实际设备之间的软件层。驱动程序的这种特权角色允许驱动程序员准确选择设备的显示方式：不同的驱动程序可以提供不同的功能，即使是相同的设备。实际的驱动程序设计应该是许多不同考虑之间的平衡。例如，一个设备可以被不同的程序并发使用，并且驱动程序员可以完全自由地决定如何处理并发。您可以实现设备的内存映射而不依赖其硬件功能，或者您可以提供一个用户库来帮助应用程序员在可用基元之上实施新策略等等。其中一个主要考虑因素是想向用户提供尽可能多的选项，和编写驱动程序所需的时间及保持简单以避免错误发生之间的平衡。

无策略驱动程序具有许多典型特征。其中包括对同步和异步操作的支持，多次打开的能力，利用硬件全部功能的能力以及缺乏软件层来“简化事物”或提供与策略相关的操作。这种驱动程序不仅对最终用户更好，而且写起来也更容易。无策略是软件设计者的通用目标。

实际上，许多设备驱动程序与用户程序一起发布，以帮助配置和访问目标设备。这些程序可以从简单程序到完整的图形应用程序。示例包括tunelp程序，它调整并行端口打印机驱动程序的操作方式，以及作为PCMCIA驱动程序包一部分的显卡控制程序。通常也提供客户端库，它提供的功能是没有作为驱动程序本身的一部分实现的功能。

本书的范围是内核，所以我们尽量不处理策略问题或应用程序或支持库。有时我们会谈论不同的策略以及如何支持这些策略，但我们不会详细介绍使用该设备的程序或实施的策略。但是，您应该了解，用户程序是软件包不可或缺的一部分，即使是无需使用策略的软件包也可以使用将默认行为应用于基础机制的配置文件进行分发。

<h2 id="1.2">1.2 划分内核</h2>

在Unix系统中，几个并发进程参与不同的任务。每个进程都会请求系统资源，比如计算能力、内存、网络连接还有其它资源。内核是负责处理所有这些请求的可执行代码。虽然不同的内核任务之间的区别并不总是清楚地标出，但是内核的职责可以被拆分（如图1-1所示）为以下几部分：

* 进程管理

    内核负责创建和销毁进程并处理与外部的连接（输入和输出）。不同进程之间的通信（通过信号，管道或进程间通信原语）是整个系统功能的基础，也是由内核处理的。另外，调度程序控制进程如何共享CPU，它是进程管理的一部分。更一般地说，内核的进程管理活动在单个CPU或几个CPU之上实现了几个进程的抽象。

* 内存管理

    计算机的内存是主要资源，用于处理它的策略对系统性能至关重要。内核为所有进程在有限的可用资源之上构建虚拟地址空间。内核的不同部分通过一组函数调用与内存管理子系统进行交互，从简单的malloc/free，到更复杂的功能。

* 文件系统

    Unix主要基于文件系统概念；几乎Unix中的所有东西都可以看作是一个文件。内核在非结构化硬件的基础上构建了一个结构化的文件系统，并且生成的文件抽象在整个系统中大量使用。另外，Linux支持多种文件系统类型，即在物理介质上组织数据的不同方式。例如，可以使用Linux标准的ext3文件系统，常用的FAT文件系统或其它几种格式化磁盘。

* 设备控制

    几乎每个系统操作最终都映射到一个物理设备。除了处理器，存储器和其它几个实体之外，所有设备控制操作都是通过特定于被寻址设备的代码执行的。该代码被称为设备驱动程序。内核必须为系统上的每个外设嵌入一个设备驱动程序，从硬盘驱动器到键盘和磁带机。内核的这个功能是本书中我们主要感兴趣的地方。

* 联网

    网络必须由操作系统管理，因为大多数网络操作不是特定于进程：接收数据包是异步事件。数据包必须在进程处理之前收集，识别和分派。系统负责在程序和网络接口之间传送数据包，并且必须根据网络活动来控制程序的执行。另外，所有的路由和寻址策略问题都在内核中实现。

<h3 id="1.2.1">1.2.1 可加载模块</h3>

Linux一个很好的功能是能够在运行时扩展内核提供的功能。 这意味着可以在系统启动并运行时向内核添加功能（或删除功能）。
可以在运行时添加到内核的代码称为module。Linux内核支持多种不同类型（或类别）的模块，包括但不限于设备驱动程序。 每个模块由目标代码组成（未链接成完整的可执行文件），可以通过insmod动态链接到正在运行的内核，并且可以由rmmod程序取消链接。

图1-1表示了负责特定任务的不同类别的模块-模块根据其提供的功能属于某一特定类别。 图1-1中的模块布局涵盖了最重要的类型，但是远远这只是一部分，因为Linux中越来越多的功能正在模块化。

![Figure 1-1](https://raw.githubusercontent.com/tupelo-shen/my_test/master/doc/linux/qemu/Linux_device_drivers_3_images/1-1.PNG)

<h2 id="1.3">1.3 设备和模块</h2>

根据Linux查看设备的方式可以将设备划分为3种基本设备类型，**字符设备**、**块设备**、**网络设备**。

* 字符设备

    字符（char）设备是可以作为字节流访问的设备（如文件）；字符设备驱动程序就是实现这种行为的程序。通常，至少实现 **open**，**close**，**read** 和 **write** 等系统调用。控制台（*/dev/console*）和串行端口（*/dev/ttyS0*）是典型的字符设备，因为它们能够很好地用数据流表示。字符设备通过文件系统节点访问，如 */dev/tty1* 和 */dev/lp0*。字符设备和普通文件之间唯一的区别在于，普通文件中可以来回移动，而大多数字符设备只是数据通道，只能依次访问。然而，也有字符设备看起来像数据区域，你可以在它们之间来回移动；例如，图像采集卡，应用程序可以使用 **mmap** 或 **lseek** 访问整个采集的图像。

* 块设备

    像字符设备一样，块设备可以通过/dev目录中的文件系统节点访问。块设备是可以托管文件系统的设备（例如，磁盘）。在大多数Unix系统中，块设备只能处理传输一个或多个块的I/O操作，这些块通常是512字节大小（或更大）。与此相反的是，Linux允许应用程序像字符设备那样读写块设备-它允许一次传输任意数量的字节。因此，块设备和字符设备的区别仅在于内核管理数据的方式，也就是内核/驱动程序软件接口。像字符设备一样，每个块设备都通过文件系统节点访问，它们之间的区别对用户来说是透明的。块驱动程序与字符设备驱动相比，内核的接口完全不同。

* 网络接口

    任何网络事务都是通过一个接口完成的，也就是能够与其它主机交换数据的设备。通常，接口是硬件设备，但它也可能是纯粹的软件设备，如loopback接口。网络接口负责发送和接收由内核网络子系统驱动的数据包，而不知道单个事务如何映射到正在传输的实际数据包。许多网络连接（特别是使用TCP的网络连接）都是面向流的，但网络设备通常是围绕数据包的传输和接收而设计的。网络驱动程序对个人连接一无所知;它只处理数据包。

不是面向流的设备，网络接口不容易映射到文件系统中的节点，如/dev/tty1所示。提供对接口访问的Unix方式仍然是给它们分配一个唯一的名字（比如eth0），但是这个名字在文件系统中没有相应的条目。内核和网络设备驱动程序之间的通信与使用字符和块驱动程序完全不同。内核调用与数据包传输相关的函数，而不用读写。

还有其它方法对上述设备驱动程序模块进行分类。一般来说，某些类型的驱动程序可以为给定类型的设备使用额外的内核支持功能层。例如，可以讨论通用串行总线（USB）模块，串行模块，SCSI模块等。每个USB设备都由可与USB子系统配合使用的USB模块驱动，但设备本身在系统中显示为字符设备（例如USB串行端口），块设备（USB存储卡读取器）或 一个网络设备（一个USB以太网接口）。

近来，也有其它类型的设备驱动程序添加到内核中，比如说FireWire驱动程序和I2O驱动程序。与处理USB和SCSI驱动方式相同，内核开发者提炼共同的功能，并将其通过接口提供给驱动开发者，以避免重复的工作和错误，从而简化了编写此类驱动程序的过程。

<div style="text-align: right"><a href="#0">回到顶部</a><a name="_label0"></a></div>
* [9.1 I/O 端口和 I/O 内存](#9.1 )
    - [9.1.1 I/O寄存器和通用内存](#9.1.1 )
* [9.2 使用 I/O 端口](#9.2 )
    * [9.2.1 申请I/O端口](#9.2.1 )
    * [9.2.2 读写I/O端口](#9.2.2 )
    * [9.2.3 从用户空间访问I/O端口](#9.2.3 )
    * [9.2.4 连续操作](#9.2.4 )
    * [9.2.5 延时访问I/O ](#9.2.5 )
    * [9.2.6 平台依赖 ](#9.2.6 )
* [9.3 一个I/O端口例子](#9.3 )
    * [9.3.1 并口概述 ](#9.3.1 )
    * [9.3.2 示例驱动程序 ](#9.3.2 )
* [9.4 使用I/O内存](#9.4 )
    * [9.4.1 I/O内存分配和映射 ](#9.4.1 )
    * [9.4.2 访问I/O内存 ](#9.4.2 )
    * [9.4.3 Ports as I/O Memory ](#9.4.3 )
    * [9.4.4 Reusing short for I/O Memory ](#9.4.4 )
    * [9.4.5 ISA Memory Below 1 MB ](#9.4.5 )
    * [9.4.6 isa_readb及其辅助函数 ](#9.4.6 )

***

scull及其变体是介绍linux设备驱动相关的软件接口和概念等的良好载体，因为实现真实的设备驱动是需要硬件的。驱动是软件和硬件电路的中间抽象层；正因如此，驱动既需要与软件通信，又要与硬件通信。到目前为止，我们一直在研究软件概念，所以，接下来我们展示驱动是如何访问I/O端口和I/O内存，并且是可移植的。

本章尽量不依赖于具体的硬件设备。但是，如果某个示例需要，我们将使用简单的数字I/O端口（比如标准的PC并口）去展示I/O指令的工作方式， 使用普通的帧缓存显卡内存展示内存映射的I/O。

简单的数字I/O是最简单的输入输出端口的实现形式之一。在大多数计算机上，都有并口，是原始的I/O：写入设备的数据就会出现在输出管脚上，输入管脚的电压可以直接被处理器访问。实际使用中，你可能需要连接LED或者打印机才能看到数字I/O操作的效果，但是这些底层硬件都很简单易用。

<h2 id="9.1">9.1 I/O 端口和 I/O 内存</h2>
***

我们通过读写寄存器控制外设。大多数时候，外设具有多个寄存器，既可以通过内存连续地址也可以通过I/O连续地址空间访问它们。

从硬件层面来说，内存区域和I/O区域没有概念上的区别：它们都可以通过地址总线和控制总线进行访问（例如，读写信号），通过数据总线读写数据。

有些CPU实现单一的地址空间，而另外一些外设和内存使用不同的地址空间。有些处理器（尤其是x86体系）拥有分别独立的读、写信号线和特殊的CPU指令访问端口。

因为外设总是去适配外设总线， 并且大多数通用I/O总线是以PC为模型的，所以即使CPU没有为I/O端口提供独立的地址空间，也必须模拟读写I/O端口去访问某些外设， 通常使用外部芯片或外围电路实现。 后一种方案在嵌入式使用的微处理器中很常见。

基于同样的原因，Linux在其运行的所有计算平台上都实现了I/O端口的概念， 即使CPU使用单个地址空间。 端口访问的实现依赖于特定的主机型号 （因为不同的型号会使用不同的芯片组将总线映射到内存地址空间）。

即使外设总线具有用于I/O端口的独立地址空间，也不是所有的设备将其寄存器映射到I/O端口上。ISA设备通常使用I/O端口， 而PCI设备映射它们的寄存器到内存地址空间。 映射到内存的这种方法通常是首选， 因为它不需要使用专用处理器指令； CPU访问内存更有效， 且编译器访问内存时， 对寄存器的分配和寻址模式的选择更自由。

<h3 id="9.1.1">9.1.1 I/O寄存器和通用内存 </h3>
***

尽管硬件寄存器和内存具有很大的相似性， 但是编程者在访问I/O寄存器的时候必须小心， 避免被CPU（或编译器）优化， 而修改了预期的I/O行为。

I/O寄存器和RAM之间主要的差别就是，I/O寄存器操作具有副作用， 而内存操作没有-唯一的影响是正在往内存写入某一值时， 内存读操作返回上一次的值。 因为内存访问速度对于CPU的性能至关重要， 这一影响早已通过多种方法被优化掉了： 比如， 缓存该值和读写指令重新排序等。

编译器可以把数据值缓存到CPU寄存器中，而不是把它们写入内存中， 即使要写入内存， 也可以在高速缓存中完成读写操作后， 再存入物理内存中。 在编译器和硬件层面也可以使用重新排序： 例如， 为了在RISC流水线内防止互锁而优化程序指令的执行顺序， 会获得更高的执行速度。 在CISC指令集处理器上， 占用大量时间的操作和执行更快的操作并发执行等。

这些优化对于内存来说可能是显而易见且有益的， 但是对于I/O操作可能就是致命的， 因为它们可能会阻碍这些“副作用”， 而这恰恰是设备驱动访问I/O寄存器的主要原因。 编译器或CPU可能会优化你所要求的操作，从而导致奇怪的错误发生，而难以调试。 因此， 当访问I/O寄存器的时候， 必须保证没有使用缓存， 没有对读写操作进行重新排序。

硬件缓存的问题很容易解决： 通过底层硬件配置（可以自动或通过Linux初始化代码）实现， 访问I/O区域（不论其是内存还是端口区域）时， 禁止硬件缓存。

编译器优化和硬件重新排序的解决方案是， 在必须以特定顺序对硬件（或另一个处理器）可见的操作之间设置内存屏障（barrier）。 Linux提供了四个宏来处理这种屏障：

    #include <linux/kernel.h>
    void barrier(void)

该函数告诉编译器插入一个内存屏障， 但是这只是软件层面的实现， 对硬件没有影响。 插入memory barrier的代码把修改后暂存在CPU寄存器中的值存储到内存中， 稍后需要的时候， 再重新从内存中读取， 即不会想当然的从CPU寄存器中取其值。 插入memory barrier 的代码阻止编译器优化， 但是不会妨碍硬件重新排序。

    #include <asm/system.h>
    void rmb(void);
    void read_barrier_depends(void);
    void wmb(void);
    void mb(void);

这些函数在编译的指令流中插入硬件内存屏障； 具体的实现还要依赖与体系架构。 rmb（读内存屏障）保证， 内存屏障之前的读操作优先于之后的读操作被完成。 wmb保证写操作的顺序， mb保证读写操作。它们都是`barrier`的超集。

`read_barrier_depends`是一种特殊的，较弱的读屏障形式。 `rmb`阻止屏障前后所有读操作的重新排序，而`read_barrier_depends`只阻止依赖于其它读操作的数据的读操作的重排序。 区别很微小， 也并不是存在于所有平台。 除非充分理解`read_barrier_depends`能干什么， 而且担心全功能的内存屏障带来严重的性能损耗之外， 应该坚持使用`rmb`。

>`read_barrier_depends`和`smp_read_barrier_depends`是读依赖屏障。除了在DEC alpha架构外， linux支持的其它的平台均不需要这个屏障。 Alpha需要它， 是因为alpha架构中，使用的缓存是split cache。 所谓split cache， 简单的说， 就是一个核的缓存不止一个。 在arm架构下， 我们可以简单的忽略这个屏障。

    void smp_rmb(void);
    void smp_read_barrier_depends(void);
    void smp_wmb(void);
    void smp_mb(void);

只有在为SMP系统编译内核时，这些版本的barrier宏才会插入硬件障碍; 否则，他们都会调用一个简单的`barrier`。

在驱动程序中使用内存屏障的大概格式如下：

    writel(dev->registers.addr, io_destination_address);
    writel(dev->registers.size, io_size);
    writel(dev->registers.operation, DEV_READ);
    wmb( );
    writel(dev->registers.control, DEV_GO);

In this case, it is important to be sure that all of the device registers controlling a particular operation have been properly set prior to telling it to begin. The memory barrier enforces the completion of the writes in the necessary order.

Because memory barriers affect performance, they should be used only where they are really needed. The different types of barriers can also have different performance characteristics, so it is worthwhile to use the most specific type possible. For example, on the x86 architecture, wmb( ) currently does nothing, since writes outside the processor are not reordered. Reads are reordered, however, so mb( ) is slower than wmb( ).

It is worth noting that most of the other kernel primitives dealing with synchronization, such as spinlockand atomic_t operations, also function as memory barriers. Also worthy of note is that some peripheral buses (such as the PCI bus) have caching issues of their own; we discuss those when we get to them in later chapters.

Some architectures allow the efficient combination of an assignment and a memory barrier. The kernel provides a few macros that perform this combination; in the default case, they are defined as follows:

    #define set_mb(var, value) do {var = value; mb( );} while 0
    #define set_wmb(var, value) do {var = value; wmb( );} while 0
    #define set_rmb(var, value) do {var = value; rmb( );} while 0

Where appropriate, <asm/system.h> defines these macros to use architecture-specific instructions that accomplish the taskmore quickly. Note that set_rmb is defined only by a small number of architectures. (The use of a do...while construct is a standard C idiom that causes the expanded macro to workas a normal C statement in all contexts.)


<h2 id="9.2">9.2 使用 I/O 端口</h2>
***

I/O ports are the means by which drivers communicate with many devices, at least part of the time. This section covers the various functions available for making use of I/O ports; we also touch on some portability issues.

<h3 id="9.2.1">9.2.1 申请I/O端口 </h3>
***

As you might expect, you should not go off and start pounding on I/O ports without first ensuring that you have exclusive access to those ports. The kernel provides a registration interface that allows your driver to claim the ports it needs. The core function in that interface is `request_region`:

    #include <linux/ioport.h>
    struct resource *request_region(unsigned long first, unsigned long n, const char *name);

This function tells the kernel that you would like to make use of `n` ports, starting with `first`. The `name` parameter should be the name of your device. The return value is non-NULL if the allocation succeeds. If you get NULL back from `request_region`, you will not be able to use the desired ports.

All port allocations show up in /proc/ioports. If you are unable to allocate a needed set of ports, that is the place to look to see who got there first.

When you are done with a set of I/O ports (at module unload time, perhaps), they should be returned to the system with:

    void release_region(unsigned long start, unsigned long n);

There is also a function that allows your driver to check to see whether a given set of I/O ports is available:

    int check_region(unsigned long first, unsigned long n);

Here, the return value is a negative error code if the given ports are not available. This function is deprecated because its return value provides no guarantee of whether an allocation would succeed; checking and later allocating are not an atomic operation. We list it here because several drivers are still using it, but you should always use request_region, which performs the required locking to ensure that the allocation is done in a safe, atomic manner.

<h3 id="9.2.2">9.2.2 读写I/O端口 </h3>
***

After a driver has requested the range of I/O ports it needs to use in its activities, it must read and/or write to those ports. To this end（为了这个目的，基于此，为此）, most hardware differentiates between 8-bit, 16-bit, and 32-bit ports. Usually you can’t mix them like you normally do with system memory access.*

> Sometimes I/O ports are arranged like memory, and you can (for example) bind two 8-bit writes into a single
> 16-bit operation. This applies, for instance, to PC video boards. But generally, you can’t count on this feature.

A C program, therefore, must call different functions to access different size ports. As suggested in the previous section, computer architectures that support only memory mapped I/O registers fake port I/O by remapping port addresses to memory addresses, and the kernel hides the details from the driver in order to ease portability. The Linux kernel headers (specifically, the architecture-dependent header `<asm/io.h>`) define the following inline functions to access I/O ports:

    unsigned inb(unsigned port);
    void outb(unsigned char byte, unsigned port);

Read or write byte ports (eight bits wide). The `port` argument is defined as unsigned long for some platforms and unsigned short for others. The return type of `inb` is also different across architectures.

    unsigned inw(unsigned port);
    void outw(unsigned short word, unsigned port);

These functions access 16-bit ports (one word wide); they are not available when compiling for the S390 platform, which supports only byte I/O.

    unsigned inl(unsigned port);
    void outl(unsigned longword, unsigned port);

These functions access 32-bit ports. longword is declared as either unsigned long or unsigned int, according to the platform. Like word I/O, “long” I/O is not available on S390.

>From now on, when we use unsigned without further type specifications, we are referring to an architecture-dependent definition whose exact nature is not relevant. The functions are almost always portable, because the compiler automatically casts the values during assignment—their being unsigned helps prevent compile-time warnings. No information is lost with such casts as long as the programmer assigns sensible values to avoid overflow. We stickto this convention of “incomplete typing” throughout this chapter.

Note that no 64-bit port I/O operations are defined. Even on 64-bit architectures, the port address space uses a 32-bit (maximum) data path.

<h3 id="9.2.3">9.2.3 从用户空间访问I/O端口 </h3>
***

The functions just described are primarily meant to be used by device drivers, but they can also be used from user space, at least on PC-class computers. The GNU C library defines them in <sys/io.h>. The following conditions should apply in order for inb and friends to be used in user-space code:

* The program must be compiled with the -O option to force expansion of inline functions.

* The `ioperm` or `iopl` system calls must be used to get permission to perform I/O operations on ports. `ioperm` gets permission for individual ports, while `iopl` gets permission for the entire I/O space. Both of these functions are x86-specific.

* The program must run as root to invoke ioperm or iopl.* Alternatively, one of its ancestors must have gained port access running as root.

If the host platform has no ioperm and no iopl system calls, user space can still access I/O ports by using the /dev/port device file. Note, however, that the meaning of the file is very platform-specific and not likely useful for anything but the PC.

The sample sources misc-progs/inp.c and misc-progs/outp.c are a minimal tool for reading and writing ports from the command line, in user space. They expect to be installed under multiple names (e.g., inb, inw, and inl and manipulates byte, word, or long ports depending on which name was invoked by the user). They use ioperm or iopl under x86, /dev/port on other platforms.

The programs can be made setuid root, if you want to live dangerously and play with your hardware without acquiring explicit privileges. Please do not install them setuid on a production system, however; they are a security hole by design.

<h3 id="9.2.4">9.2.4 连续操作 </h3>
***

In addition to the single-shot in and out operations, some processors implement special instructions to transfer a sequence of bytes, words, or longs to and from a single I/O port or the same size. These are the so-called string instructions, and they perform the task more quickly than a C-language loop can do. The following macros implement the concept of string I/O either by using a single machine instruction or by executing a tight loop if the target processor has no instruction that performs string I/O. The macros are not defined at all when compiling for the S390 platform. This should not be a portability problem, since this platform doesn’t usually share device drivers with other platforms, because its peripheral buses are different.

The prototypes for string functions are:

    void insb(unsigned port, void *addr, unsigned long count);
    void outsb(unsigned port, void *addr, unsigned long count);

Read or write `count` bytes starting at the memory address `addr`. Data is read from or written to the single port `port`.

    void insw(unsigned port, void *addr, unsigned long count);
    void outsw(unsigned port, void *addr, unsigned long count);

Read or write 16-bit values to a single 16-bit port.

    void insl(unsigned port, void *addr, unsigned long count);
    void outsl(unsigned port, void *addr, unsigned long count);

Read or write 32-bit values to a single 32-bit port.

There is one thing to keep in mind when using the string functions: they move a straight byte stream to or from the port. When the port and the host system have different byte ordering rules, the results can be surprising. Reading a port with `inw` swaps the bytes, if need be, to make the value read match the host ordering. The string functions, instead, do not perform this swapping.


<h3 id="9.2.5">9.2.5 延时访问I/O </h3>
***

Some platforms—most notably the i386—can have problems when the processor tries to transfer data too quickly to or from the bus. The problems can arise when the processor is overclocked with respect to the peripheral bus (think ISA here) and can show up when the device board is too slow. The solution is to insert a small delay after each I/O instruction if another such instruction follows. On the x86, the pause is achieved by performing an out b instruction to port 0x80 (normally but not always unused), or by busy waiting. See the `io.h` file under your platform’s asm subdirectory for details.

If your device misses some data, or if you fear it might miss some, you can use pausing functions in place of the normal ones. The pausing functions are exactly like those listed previously, but their names end `in_p`; they are called `inb_p`, `outb_p`, and so on. The functions are defined for most supported architectures, although they often expand to the same code as nonpausing I/O, because there is no need for the extra pause if the architecture runs with a reasonably modern peripheral bus.


<h3 id="9.2.6">9.2.6 Platform Dependencies </h3>
***

I/O instructions are, by their nature, highly processor dependent. Because they work with the details of how the processor handles moving data in and out, it is very hard to hide the differences between systems. As a consequence, much of the source code related to port I/O is platform-dependent.

You can see one of the incompatibilities, data typing, by looking back at the list of functions, where the arguments are typed differently based on the architectural differences between platforms. For example, a port is unsigned short on the x86 (where the processor supports a 64-KB I/O space), but unsigned long on other platforms, whose ports are just special locations in the same address space as memory.

Other platform dependencies arise from basic structural differences in the processors and are, therefore, unavoidable. We won’t go into detail about the differences, because we assume that you won’t be writing a device driver for a particular system without understanding the underlying hardware. Instead, here is an overview of the capabilities of the architectures supported by the kernel:

    IA-32 (x86)
    x86_64

The architecture supports all the functions described in this chapter. Port numbers are of type unsigned short.

    IA-64 (Itanium)

All functions are supported; ports are unsigned long (and memory-mapped). String functions are implemented in C.

    Alpha

All the functions are supported, and ports are memory-mapped. The implementation of port I/O is different in different Alpha platforms, according to the chipset they use. String functions are implemented in C and defined in arch/
alpha/lib/io.c. Ports are unsigned long.

    ARM

Ports are memory-mapped, and all functions are supported; string functions are implemented in C. Ports are of type unsigned int.

    Cris

This architecture does not support the I/O port abstraction even in an emulated mode; the various port operations are defined to do nothing at all.

    M68k
    M68k-nommu

Ports are memory-mapped. String functions are supported, and the port type is unsigned char *.

    MIPS
    MIPS64

The MIPS port supports all the functions. String operations are implemented with tight assembly loops, because the processor lacks machine-level string I/O. Ports are memory-mapped; they are unsigned long.

    PA-RISC

All of the functions are supported; ports are int on PCI-based systems and unsigned short on EISA systems, except for string operations, which use unsigned long port numbers.

    PowerPC
    PowerPC64

All the functions are supported; ports have type unsigned char * on 32-bit systems and unsigned long on 64-bit systems.

    S390

Similar to the M68k, the header for this platform supports only byte-wide port I/O with no string operations. Ports are char pointers and are memory-mapped.

    Super-H

Ports are unsigned int (memory-mapped), and all the functions are supported.

    SPARC
    SPARC64

Once again, I/O space is memory-mapped. Versions of the port functions are defined to work with unsigned long ports.

The curious reader can extract more information from the io.h files, which sometimes define a few architecture-specific functions in addition to those we describe in this chapter. Be warned that some of these files are rather difficult reading, however.

It’s interesting to note that no processor outside the x86 family features a different address space for ports, even though several of the supported families are shipped with ISA and/or PCI slots (and both buses implement separate I/O and memory address spaces).

Moreover, some processors (most notably the early Alphas) lack instructions that move one or two bytes at a time.* Therefore, their peripheral chipsets simulate 8-bit and 16-bit I/O accesses by mapping them to special address ranges in the memory address space. Thus, an `inb` and an `inw` instruction that act on the same port are implemented by two 32-bit memory reads that operate on different addresses. Fortunately, all of this is hidden from the device driver writer by the internals of the macros described in this section, but we feel it’s an interesting feature to note. If you want to probe further, look for examples in include/asm-alpha/core_lca.h.

How I/O operations are performed on each platform is well described in the programmer’s manual for each platform; those manuals are usually available for download as PDFs on the Web.

<h2 id="9.3">9.3 一个I/O端口例子</h2>
***

The sample code we use to show port I/O from within a device driver acts on general-purpose digital I/O ports; such ports are found in most computer systems.

A digital I/O port, in its most common incarnation, is a byte-wide I/O location, either memory-mapped or port-mapped. When you write a value to an output location, the electrical signal seen on output pins is changed according to the individual bits being written. When you read a value from the input location, the current logic level seen on input pins is returned as individual bit values.

The actual implementation and software interface of such I/O ports varies from system to system. Most of the time, I/O pins are controlled by two I/O locations: one that allows selecting what pins are used as input and what pins are used as output and one in which you can actually read or write logic levels. Sometimes, however, things are even simpler, and the bits are hardwired as either input or output (but, in this case, they’re no longer called “general-purpose I/O”); the parallel port found on all personal computers is one such not-so-general-purpose I/O port. Either way, the I/O pins are usable by the sample code we introduce shortly.

<h3 id="9.3.1">9.3.1 An Overview of the Parallel Port </h3>
***

Because we expect most readers to be using an x86 platform in the form called “personal computer,” we feel it is worth explaining how the PC parallel port is designed. The parallel port is the peripheral interface of choice for running digital I/O sample code on a personal computer. Although most readers probably have parallel port specifications available, we summarize them here for your convenience.

The parallel interface, in its minimal configuration (we overlook the ECP and EPP modes) is made up of three 8-bit ports. The PC standard starts the I/O ports for the first parallel interface at 0x378 and for the second at 0x278. The first port is a bidirectional data register; it connects directly to pins 2–9 on the physical connector. The second port is a read-only status register; when the parallel port is being used for a printer, this register reports several aspects of printer status, such as being online, out of paper, or busy. The third port is an output-only control register, which, among other things, controls whether interrupts are enabled.

The signal levels used in parallel communications are standard transistor-transistor logic (TTL) levels: 0 and 5 volts, with the logic threshold at about 1.2 volts. You can count on the ports at least meeting the standard TTL LS current ratings, although most modern parallel ports do better in both current and voltage ratings.

> The parallel connector is not isolated from the computer’s internal circuitry, which is useful if you want to connect
> logic gates directly to the port. But you have to be careful to do the wiring correctly; the parallel port circuitry
> is easily damaged when you play with your own custom circuitry, unless you add optoisolators to your circuit. You can
> choose to use plug-in parallel ports if you fear you’ll damage your motherboard.

The bit specifications are outlined in Figure 9-1. You can access 12 output bits and 5 input bits, some of which are logically inverted over the course of their signal path. The only bit with no associated signal pin is bit 4 (0x10) of port 2, which enables interrupts from the parallel port. We use this bit as part of our implementation of an interrupt handler in Chapter 10.

![Figure 9-1. The pinout of the parallel port](https://raw.githubusercontent.com/tupelo-shen/my_test/master/doc/linux/qemu/Linux_device_drivers_3_images/9-1.PNG)



<h3 id="9.3.2">9.3.2 A Sample Driver </h3>
***

<h2 id="9.4">9.4 Using I/O Memory</h2>
***

<h3 id="9.4.1">9.4.1 I/O Memory Allocation and Mapping </h3>
***

<h3 id="9.4.2">9.4.2 Accessing I/O Memory </h3>
***

<h3 id="9.4.3">9.4.3 Ports as I/O Memory </h3>
***

<h3 id="9.4.4">9.4.4 Reusing short for I/O Memory </h3>
***

<h3 id="9.4.5">9.4.5 ISA Memory Below 1 MB </h3>
***

<h3 id="9.4.6">9.4.6 isa_readb and Friends </h3>
***
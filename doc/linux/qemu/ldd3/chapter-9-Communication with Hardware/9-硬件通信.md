* [9.1 I/O 端口和 I/O 内存](#9.1 )
    - [9.1.1 I/O寄存器和通用内存](#9.1.1 )
* [9.2 使用 I/O 端口](#9.2 )
    * [9.2.1 申请I/O端口](#9.2.1 )
    * [9.2.2 读写I/O端口](#9.2.2 )
    * [9.2.3 从用户空间访问I/O端口](#9.2.3 )
    * [9.2.4 连续操作](#9.2.4 )
    * [9.2.5 延时访问I/O ](#9.2.5 )
    * [9.2.6 平台依赖 ](#9.2.6 )
* [9.3 一个I/O端口例子](#9.3 )
    * [9.3.1 并口概述](#9.3.1 )
    * [9.3.2 示例驱动程序](#9.3.2 )
* [9.4 使用I/O内存](#9.4 )
    * [9.4.1 I/O内存分配和映射](#9.4.1 )
    * [9.4.2 访问I/O内存](#9.4.2 )
    * [9.4.3 端口模拟为I/O内存](#9.4.3 )
    * [9.4.4 为I/O重用short](#9.4.4 )
    * [9.4.5 ISA Memory Below 1 MB ](#9.4.5 )
    * [9.4.6 isa_readb及其辅助函数 ](#9.4.6 )

***

scull及其变体是介绍linux设备驱动相关的软件接口和概念等的良好载体，因为实现真实的设备驱动是需要硬件的。驱动是软件和硬件电路的中间抽象层；正因如此，驱动既需要与软件通信，又要与硬件通信。到目前为止，我们一直在研究软件概念，所以，接下来我们展示驱动是如何访问I/O端口和I/O内存，并且是可移植的。

本章尽量不依赖于具体的硬件设备。但是，如果某个示例需要，我们将使用简单的数字I/O端口（比如标准的PC并口）去展示I/O指令的工作方式， 使用普通的帧缓存显卡内存展示内存映射的I/O。

简单的数字I/O是最简单的输入输出端口的实现形式之一。在大多数计算机上，都有并口，是原始的I/O：写入设备的数据就会出现在输出管脚上，输入管脚的电压可以直接被处理器访问。实际使用中，你可能需要连接LED或者打印机才能看到数字I/O操作的效果，但是这些底层硬件都很简单易用。

<h2 id="9.1">9.1 I/O 端口和 I/O 内存</h2>
***

我们通过读写寄存器控制外设。大多数时候，外设具有多个寄存器，既可以通过内存连续地址也可以通过I/O连续地址空间访问它们。

从硬件层面来说，内存区域和I/O区域没有概念上的区别：它们都可以通过地址总线和控制总线进行访问（例如，读写信号），通过数据总线读写数据。

有些CPU实现单一的地址空间，而另外一些外设和内存使用不同的地址空间。有些处理器（尤其是x86体系）拥有分别独立的读、写信号线和特殊的CPU指令访问端口。

因为外设总是去适配外设总线， 并且大多数通用I/O总线是以PC为模型的，所以即使CPU没有为I/O端口提供独立的地址空间，也必须模拟读写I/O端口去访问某些外设， 通常使用外部芯片或外围电路实现。 后一种方案在嵌入式使用的微处理器中很常见。

基于同样的原因，Linux在其运行的所有计算平台上都实现了I/O端口的概念， 即使CPU使用单个地址空间。 端口访问的实现依赖于特定的主机型号 （因为不同的型号会使用不同的芯片组将总线映射到内存地址空间）。

即使外设总线具有用于I/O端口的独立地址空间，也不是所有的设备将其寄存器映射到I/O端口上。ISA设备通常使用I/O端口， 而PCI设备映射它们的寄存器到内存地址空间。 映射到内存的这种方法通常是首选， 因为它不需要使用专用处理器指令； CPU访问内存更有效， 且编译器访问内存时， 对寄存器的分配和寻址模式的选择更自由。

<h3 id="9.1.1">9.1.1 I/O寄存器和通用内存 </h3>
***

尽管硬件寄存器和内存具有很大的相似性， 但是编程者在访问I/O寄存器的时候必须小心， 避免被CPU（或编译器）优化， 而修改了预期的I/O行为。

I/O寄存器和RAM之间主要的差别就是，I/O寄存器操作具有副作用， 而内存操作没有-唯一的影响是正在往内存写入某一值时， 内存读操作返回上一次的值。 因为内存访问速度对于CPU的性能至关重要， 这一影响早已通过多种方法被优化掉了： 比如， 缓存该值和读写指令重新排序等。

编译器可以把数据值缓存到CPU寄存器中，而不是把它们写入内存中， 即使要写入内存， 也可以在高速缓存中完成读写操作后， 再存入物理内存中。 在编译器和硬件层面也可以使用重新排序： 例如， 为了在RISC流水线内防止互锁而优化程序指令的执行顺序， 会获得更高的执行速度。 在CISC指令集处理器上， 占用大量时间的操作和执行更快的操作并发执行等。

这些优化对于内存来说可能是显而易见且有益的， 但是对于I/O操作可能就是致命的， 因为它们可能会阻碍这些“副作用”， 而这恰恰是设备驱动访问I/O寄存器的主要原因。 编译器或CPU可能会优化你所要求的操作，从而导致奇怪的错误发生，而难以调试。 因此， 当访问I/O寄存器的时候， 必须保证没有使用缓存， 没有对读写操作进行重新排序。

硬件缓存的问题很容易解决： 通过底层硬件配置（可以自动或通过Linux初始化代码）实现， 访问I/O区域（不论其是内存还是端口区域）时， 禁止硬件缓存。

编译器优化和硬件重新排序的解决方案是， 在必须以特定顺序对硬件（或另一个处理器）可见的操作之间设置内存屏障（barrier）。 Linux提供了四个宏来处理这种屏障：

    #include <linux/kernel.h>
    void barrier(void)

该函数告诉编译器插入一个内存屏障， 但是这只是软件层面的实现， 对硬件没有影响。 插入memory barrier的代码把修改后暂存在CPU寄存器中的值存储到内存中， 稍后需要的时候， 再重新从内存中读取， 即不会想当然的从CPU寄存器中取其值。 插入memory barrier 的代码阻止编译器优化， 但是不会妨碍硬件重新排序。

    #include <asm/system.h>
    void rmb(void);
    void read_barrier_depends(void);
    void wmb(void);
    void mb(void);

这些函数在编译的指令流中插入硬件内存屏障； 具体的实现还要依赖与体系架构。 rmb（读内存屏障）保证， 内存屏障之前的读操作优先于之后的读操作被完成。 wmb保证写操作的顺序， mb保证读写操作。它们都是`barrier`的超集。

`read_barrier_depends`是一种特殊的，较弱的读屏障形式。 `rmb`阻止屏障前后所有读操作的重新排序，而`read_barrier_depends`只阻止依赖于其它读操作的数据的读操作的重排序。 区别很微小， 也并不是存在于所有平台。 除非充分理解`read_barrier_depends`能干什么， 而且担心全功能的内存屏障带来严重的性能损耗之外， 应该坚持使用`rmb`。

>`read_barrier_depends`和`smp_read_barrier_depends`是读依赖屏障。除了在DEC alpha架构外， linux支持的其它的平台均不需要这个屏障。 Alpha需要它， 是因为alpha架构中，使用的缓存是split cache。 所谓split cache， 简单的说， 就是一个核的缓存不止一个。 在arm架构下， 我们可以简单的忽略这个屏障。

    void smp_rmb(void);
    void smp_read_barrier_depends(void);
    void smp_wmb(void);
    void smp_mb(void);

只有在为SMP系统编译内核时，这些版本的barrier宏才会插入硬件障碍; 否则，他们都会调用一个简单的`barrier`。

在驱动程序中使用内存屏障的大概格式如下：

    writel(dev->registers.addr, io_destination_address);
    writel(dev->registers.size, io_size);
    writel(dev->registers.operation, DEV_READ);
    wmb( );
    writel(dev->registers.control, DEV_GO);

In this case, it is important to be sure that all of the device registers controlling a particular operation have been properly set prior to telling it to begin. The memory barrier enforces the completion of the writes in the necessary order.

Because memory barriers affect performance, they should be used only where they are really needed. The different types of barriers can also have different performance characteristics, so it is worthwhile to use the most specific type possible. For example, on the x86 architecture, wmb( ) currently does nothing, since writes outside the processor are not reordered. Reads are reordered, however, so mb( ) is slower than wmb( ).

It is worth noting that most of the other kernel primitives dealing with synchronization, such as spinlockand atomic_t operations, also function as memory barriers. Also worthy of note is that some peripheral buses (such as the PCI bus) have caching issues of their own; we discuss those when we get to them in later chapters.

Some architectures allow the efficient combination of an assignment and a memory barrier. The kernel provides a few macros that perform this combination; in the default case, they are defined as follows:

    #define set_mb(var, value) do {var = value; mb( );} while 0
    #define set_wmb(var, value) do {var = value; wmb( );} while 0
    #define set_rmb(var, value) do {var = value; rmb( );} while 0

Where appropriate, <asm/system.h> defines these macros to use architecture-specific instructions that accomplish the taskmore quickly. Note that set_rmb is defined only by a small number of architectures. (The use of a do...while construct is a standard C idiom that causes the expanded macro to workas a normal C statement in all contexts.)


<h2 id="9.2">9.2 使用 I/O 端口</h2>
***

I/O ports are the means by which drivers communicate with many devices, at least part of the time. This section covers the various functions available for making use of I/O ports; we also touch on some portability issues.

<h3 id="9.2.1">9.2.1 申请I/O端口 </h3>
***

As you might expect, you should not go off and start pounding on I/O ports without first ensuring that you have exclusive access to those ports. The kernel provides a registration interface that allows your driver to claim the ports it needs. The core function in that interface is `request_region`:

    #include <linux/ioport.h>
    struct resource *request_region(unsigned long first, unsigned long n, const char *name);

This function tells the kernel that you would like to make use of `n` ports, starting with `first`. The `name` parameter should be the name of your device. The return value is non-NULL if the allocation succeeds. If you get NULL back from `request_region`, you will not be able to use the desired ports.

All port allocations show up in /proc/ioports. If you are unable to allocate a needed set of ports, that is the place to look to see who got there first.

When you are done with a set of I/O ports (at module unload time, perhaps), they should be returned to the system with:

    void release_region(unsigned long start, unsigned long n);

There is also a function that allows your driver to check to see whether a given set of I/O ports is available:

    int check_region(unsigned long first, unsigned long n);

Here, the return value is a negative error code if the given ports are not available. This function is deprecated because its return value provides no guarantee of whether an allocation would succeed; checking and later allocating are not an atomic operation. We list it here because several drivers are still using it, but you should always use request_region, which performs the required locking to ensure that the allocation is done in a safe, atomic manner.

<h3 id="9.2.2">9.2.2 读写I/O端口 </h3>
***

After a driver has requested the range of I/O ports it needs to use in its activities, it must read and/or write to those ports. To this end（为了这个目的，基于此，为此）, most hardware differentiates between 8-bit, 16-bit, and 32-bit ports. Usually you can’t mix them like you normally do with system memory access.*

> Sometimes I/O ports are arranged like memory, and you can (for example) bind two 8-bit writes into a single
> 16-bit operation. This applies, for instance, to PC video boards. But generally, you can’t count on this feature.

A C program, therefore, must call different functions to access different size ports. As suggested in the previous section, computer architectures that support only memory mapped I/O registers fake port I/O by remapping port addresses to memory addresses, and the kernel hides the details from the driver in order to ease portability. The Linux kernel headers (specifically, the architecture-dependent header `<asm/io.h>`) define the following inline functions to access I/O ports:

    unsigned inb(unsigned port);
    void outb(unsigned char byte, unsigned port);

Read or write byte ports (eight bits wide). The `port` argument is defined as unsigned long for some platforms and unsigned short for others. The return type of `inb` is also different across architectures.

    unsigned inw(unsigned port);
    void outw(unsigned short word, unsigned port);

These functions access 16-bit ports (one word wide); they are not available when compiling for the S390 platform, which supports only byte I/O.

    unsigned inl(unsigned port);
    void outl(unsigned longword, unsigned port);

These functions access 32-bit ports. longword is declared as either unsigned long or unsigned int, according to the platform. Like word I/O, “long” I/O is not available on S390.

>From now on, when we use unsigned without further type specifications, we are referring to an architecture-dependent definition whose exact nature is not relevant. The functions are almost always portable, because the compiler automatically casts the values during assignment—their being unsigned helps prevent compile-time warnings. No information is lost with such casts as long as the programmer assigns sensible values to avoid overflow. We stickto this convention of “incomplete typing” throughout this chapter.

Note that no 64-bit port I/O operations are defined. Even on 64-bit architectures, the port address space uses a 32-bit (maximum) data path.

<h3 id="9.2.3">9.2.3 从用户空间访问I/O端口 </h3>
***

The functions just described are primarily meant to be used by device drivers, but they can also be used from user space, at least on PC-class computers. The GNU C library defines them in <sys/io.h>. The following conditions should apply in order for inb and friends to be used in user-space code:

* The program must be compiled with the -O option to force expansion of inline functions.

* The `ioperm` or `iopl` system calls must be used to get permission to perform I/O operations on ports. `ioperm` gets permission for individual ports, while `iopl` gets permission for the entire I/O space. Both of these functions are x86-specific.

* The program must run as root to invoke ioperm or iopl.* Alternatively, one of its ancestors must have gained port access running as root.

If the host platform has no ioperm and no iopl system calls, user space can still access I/O ports by using the /dev/port device file. Note, however, that the meaning of the file is very platform-specific and not likely useful for anything but the PC.

The sample sources misc-progs/inp.c and misc-progs/outp.c are a minimal tool for reading and writing ports from the command line, in user space. They expect to be installed under multiple names (e.g., inb, inw, and inl and manipulates byte, word, or long ports depending on which name was invoked by the user). They use ioperm or iopl under x86, /dev/port on other platforms.

The programs can be made setuid root, if you want to live dangerously and play with your hardware without acquiring explicit privileges. Please do not install them setuid on a production system, however; they are a security hole by design.

<h3 id="9.2.4">9.2.4 连续操作 </h3>
***

In addition to the single-shot in and out operations, some processors implement special instructions to transfer a sequence of bytes, words, or longs to and from a single I/O port or the same size. These are the so-called string instructions, and they perform the task more quickly than a C-language loop can do. The following macros implement the concept of string I/O either by using a single machine instruction or by executing a tight loop if the target processor has no instruction that performs string I/O. The macros are not defined at all when compiling for the S390 platform. This should not be a portability problem, since this platform doesn’t usually share device drivers with other platforms, because its peripheral buses are different.

The prototypes for string functions are:

    void insb(unsigned port, void *addr, unsigned long count);
    void outsb(unsigned port, void *addr, unsigned long count);

Read or write `count` bytes starting at the memory address `addr`. Data is read from or written to the single port `port`.

    void insw(unsigned port, void *addr, unsigned long count);
    void outsw(unsigned port, void *addr, unsigned long count);

Read or write 16-bit values to a single 16-bit port.

    void insl(unsigned port, void *addr, unsigned long count);
    void outsl(unsigned port, void *addr, unsigned long count);

Read or write 32-bit values to a single 32-bit port.

There is one thing to keep in mind when using the string functions: they move a straight byte stream to or from the port. When the port and the host system have different byte ordering rules, the results can be surprising. Reading a port with `inw` swaps the bytes, if need be, to make the value read match the host ordering. The string functions, instead, do not perform this swapping.


<h3 id="9.2.5">9.2.5 延时访问I/O </h3>
***

Some platforms—most notably the i386—can have problems when the processor tries to transfer data too quickly to or from the bus. The problems can arise when the processor is overclocked with respect to the peripheral bus (think ISA here) and can show up when the device board is too slow. The solution is to insert a small delay after each I/O instruction if another such instruction follows. On the x86, the pause is achieved by performing an out b instruction to port 0x80 (normally but not always unused), or by busy waiting. See the `io.h` file under your platform’s asm subdirectory for details.

If your device misses some data, or if you fear it might miss some, you can use pausing functions in place of the normal ones. The pausing functions are exactly like those listed previously, but their names end `in_p`; they are called `inb_p`, `outb_p`, and so on. The functions are defined for most supported architectures, although they often expand to the same code as nonpausing I/O, because there is no need for the extra pause if the architecture runs with a reasonably modern peripheral bus.


<h3 id="9.2.6">9.2.6 平台依赖 </h3>
***

I/O instructions are, by their nature, highly processor dependent. Because they work with the details of how the processor handles moving data in and out, it is very hard to hide the differences between systems. As a consequence, much of the source code related to port I/O is platform-dependent.

You can see one of the incompatibilities, data typing, by looking back at the list of functions, where the arguments are typed differently based on the architectural differences between platforms. For example, a port is unsigned short on the x86 (where the processor supports a 64-KB I/O space), but unsigned long on other platforms, whose ports are just special locations in the same address space as memory.

Other platform dependencies arise from basic structural differences in the processors and are, therefore, unavoidable. We won’t go into detail about the differences, because we assume that you won’t be writing a device driver for a particular system without understanding the underlying hardware. Instead, here is an overview of the capabilities of the architectures supported by the kernel:

    IA-32 (x86)
    x86_64

The architecture supports all the functions described in this chapter. Port numbers are of type unsigned short.

    IA-64 (Itanium)

All functions are supported; ports are unsigned long (and memory-mapped). String functions are implemented in C.

    Alpha

All the functions are supported, and ports are memory-mapped. The implementation of port I/O is different in different Alpha platforms, according to the chipset they use. String functions are implemented in C and defined in arch/
alpha/lib/io.c. Ports are unsigned long.

    ARM

Ports are memory-mapped, and all functions are supported; string functions are implemented in C. Ports are of type unsigned int.

    Cris

This architecture does not support the I/O port abstraction even in an emulated mode; the various port operations are defined to do nothing at all.

    M68k
    M68k-nommu

Ports are memory-mapped. String functions are supported, and the port type is unsigned char *.

    MIPS
    MIPS64

The MIPS port supports all the functions. String operations are implemented with tight assembly loops, because the processor lacks machine-level string I/O. Ports are memory-mapped; they are unsigned long.

    PA-RISC

All of the functions are supported; ports are int on PCI-based systems and unsigned short on EISA systems, except for string operations, which use unsigned long port numbers.

    PowerPC
    PowerPC64

All the functions are supported; ports have type unsigned char * on 32-bit systems and unsigned long on 64-bit systems.

    S390

Similar to the M68k, the header for this platform supports only byte-wide port I/O with no string operations. Ports are char pointers and are memory-mapped.

    Super-H

Ports are unsigned int (memory-mapped), and all the functions are supported.

    SPARC
    SPARC64

Once again, I/O space is memory-mapped. Versions of the port functions are defined to work with unsigned long ports.

The curious reader can extract more information from the io.h files, which sometimes define a few architecture-specific functions in addition to those we describe in this chapter. Be warned that some of these files are rather difficult reading, however.

It’s interesting to note that no processor outside the x86 family features a different address space for ports, even though several of the supported families are shipped with ISA and/or PCI slots (and both buses implement separate I/O and memory address spaces).

Moreover, some processors (most notably the early Alphas) lack instructions that move one or two bytes at a time.* Therefore, their peripheral chipsets simulate 8-bit and 16-bit I/O accesses by mapping them to special address ranges in the memory address space. Thus, an `inb` and an `inw` instruction that act on the same port are implemented by two 32-bit memory reads that operate on different addresses. Fortunately, all of this is hidden from the device driver writer by the internals of the macros described in this section, but we feel it’s an interesting feature to note. If you want to probe further, look for examples in include/asm-alpha/core_lca.h.

How I/O operations are performed on each platform is well described in the programmer’s manual for each platform; those manuals are usually available for download as PDFs on the Web.

<h2 id="9.3">9.3 一个I/O端口例子</h2>
***

The sample code we use to show port I/O from within a device driver acts on general-purpose digital I/O ports; such ports are found in most computer systems.

A digital I/O port, in its most common incarnation, is a byte-wide I/O location, either memory-mapped or port-mapped. When you write a value to an output location, the electrical signal seen on output pins is changed according to the individual bits being written. When you read a value from the input location, the current logic level seen on input pins is returned as individual bit values.

The actual implementation and software interface of such I/O ports varies from system to system. Most of the time, I/O pins are controlled by two I/O locations: one that allows selecting what pins are used as input and what pins are used as output and one in which you can actually read or write logic levels. Sometimes, however, things are even simpler, and the bits are hardwired as either input or output (but, in this case, they’re no longer called “general-purpose I/O”); the parallel port found on all personal computers is one such not-so-general-purpose I/O port. Either way, the I/O pins are usable by the sample code we introduce shortly.

<h3 id="9.3.1">9.3.1 An Overview of the Parallel Port </h3>
***

Because we expect most readers to be using an x86 platform in the form called “personal computer,” we feel it is worth explaining how the PC parallel port is designed. The parallel port is the peripheral interface of choice for running digital I/O sample code on a personal computer. Although most readers probably have parallel port specifications available, we summarize them here for your convenience.

The parallel interface, in its minimal configuration (we overlook the ECP and EPP modes) is made up of three 8-bit ports. The PC standard starts the I/O ports for the first parallel interface at 0x378 and for the second at 0x278. The first port is a bidirectional data register; it connects directly to pins 2–9 on the physical connector. The second port is a read-only status register; when the parallel port is being used for a printer, this register reports several aspects of printer status, such as being online, out of paper, or busy. The third port is an output-only control register, which, among other things, controls whether interrupts are enabled.

The signal levels used in parallel communications are standard transistor-transistor logic (TTL) levels: 0 and 5 volts, with the logic threshold at about 1.2 volts. You can count on the ports at least meeting the standard TTL LS current ratings, although most modern parallel ports do better in both current and voltage ratings.

> The parallel connector is not isolated from the computer’s internal circuitry, which is useful if you want to connect
> logic gates directly to the port. But you have to be careful to do the wiring correctly; the parallel port circuitry
> is easily damaged when you play with your own custom circuitry, unless you add optoisolators to your circuit. You can
> choose to use plug-in parallel ports if you fear you’ll damage your motherboard.

The bit specifications are outlined in Figure 9-1. You can access 12 output bits and 5 input bits, some of which are logically inverted over the course of their signal path. The only bit with no associated signal pin is bit 4 (0x10) of port 2, which enables interrupts from the parallel port. We use this bit as part of our implementation of an interrupt handler in Chapter 10.

![Figure 9-1. The pinout of the parallel port](https://raw.githubusercontent.com/tupelo-shen/my_test/master/doc/linux/qemu/Linux_device_drivers_3_images/9-1.PNG)



<h3 id="9.3.2">9.3.2 示例驱动程序 </h3>
***

The driver we introduce is called `short` (Simple Hardware Operations and Raw Tests). All it does is read and write a few 8-bit ports, starting from the one you select at load time. By default, it uses the port range assigned to the parallel interface of the PC. Each device node (with a unique minor number) accesses a different port. The `short` driver doesn’t do anything useful; it just isolates for external use as a single instruction acting on a port. If you are not used to port I/O, you can use `short` to get familiar with it; you can measure the time it takes to transfer data through a port or play other games.

For short to work on your system, it must have free access to the underlying hardware device (by default, the parallel interface); thus, no other driver may have allocated it. Most modern distributions set up the parallel port drivers as modules that are loaded only when needed, so contention for the I/O addresses is not usually a problem. If, however, you get a “can’t get I/O address” error from `short` (on the console or in the system log file), some other driver has probably already taken the port. A quick look at /proc/ioports usually tells you which driver is getting in the way. The same caveat applies to other I/O devices if you are not using the parallel interface.

From now on, we just refer to “the parallel interface” to simplify the discussion. However, you can set the base module parameter at load time to redirect `short` to other I/O devices. This feature allows the sample code to run on any Linux platform where you have access to a digital I/O interface that is accessible via `outb` and `inb` (even though the actual hardware is memory-mapped on all platforms but the x86). Later, in the section “Using I/O Memory,” we show how `short` can be used with generic memory-mapped digital I/O as well.

To watch what happens on the parallel connector and if you have a bit of an inclination to work with hardware, you can solder a few LEDs to the output pins. Each LED should be connected in series to a 1-KΩ resistor leading to a ground pin (unless, of course, your LEDs have the resistor built in). If you connect an output pin to an input pin, you’ll generate your own input to be read from the input ports.

Note that you cannot just connect a printer to the parallel port and see data sent to `short`. This driver implements simple access to the I/O ports and does not perform the handshake that printers need to operate on the data. In the next chapter, we show a sample driver (called shortprint), that is capable of driving parallel printers; that driver uses interrupts, however, so we can’t get to it quite yet.

If you are going to view parallel data by soldering LEDs to a D-type connector, we suggest that you not use pins 9 and 10, because we connect them together later to run the sample code shown in Chapter 10.

As far as `short` is concerned, /dev/short0 writes to and reads from the 8-bit port located at the I/O address base (0x378 unless changed at load time). /dev/short1 writes to the 8-bit port located at base + 1, and so on up to base + 7.

The actual output operation performed by /dev/short0 is based on a tight loop using `outb`. A memory barrier instruction is used to ensure that the output operation actually takes place and is not optimized away:

    while (count--) {
        outb(*(ptr++), port);
        wmb( );
    }

You can run the following command to light your LEDs:

    echo -n "any string" > /dev/short0

Each LED monitors a single bit of the output port. Remember that only the last character written remains steady on the output pins long enough to be perceived by your eyes. For that reason, we suggest that you prevent automatic insertion of a trailing newline by passing the -n option to echo.

Reading is performed by a similar function, built around `inb` instead of `outb`. In order to read “meaningful” values from the parallel port, you need to have some hardware connected to the input pins of the connector to generate signals. If there is no signal, you read an endless stream of identical bytes. If you choose to read from an output port, you most likely get back the last value written to the port (this applies to the parallel interface and to most other digital I/O circuits in common use). Thus, those uninclined to get out their soldering irons can read the current output value on port 0x378 by running a command such as:

    dd if=/dev/short0 bs=1 count=1 | od -t x1

To demonstrate the use of all the I/O instructions, there are three variations of each `short` device: /dev/short0 performs the loop just shown, /dev/short0p uses `outb_p` and `inb_p` in place of the “fast” functions, and /dev/short0s uses the string instructions. There are eight such devices, from short0 to short7. Although the PC parallel interface has only three ports, you may need more of them if using a different I/O device to run your tests.

The `short` driver performs an absolute minimum of hardware control but is adequate to show how the I/O port instructions are used. Interested readers may want to look at the source for the `parport` and `parport_pc` modules to see how complicated this device can get in real life in order to support a range of devices (printers, tape backup, network interfaces) on the parallel port.

<h2 id="9.4">9.4 Using I/O Memory</h2>
***

Despite the popularity of I/O ports in the x86 world, the main mechanism used to communicate with devices is through memory-mapped registers and device memory. Both are called I/O memory because the difference between registers and memory is transparent to software.

I/O memory is simply a region of RAM-like locations that the device makes available to the processor over the bus. This memory can be used for a number of purposes, such as holding video data or Ethernet packets, as well as implementing device registers that behave just like I/O ports (i.e., they have side effects associated with reading and writing them).

The way to access I/O memory depends on the computer architecture, bus, and device being used, although the principles are the same everywhere. The discussion in this chapter touches mainly on ISA and PCI memory, while trying to convey general information as well. Although access to PCI memory is introduced here, a thorough discussion of PCI is deferred to Chapter 12.

Depending on the computer platform and bus being used, I/O memory may or may not be accessed through page tables. When access passes though page tables, the kernel must first arrange for the physical address to be visible from your driver, and this usually means that you must call `ioremap` before doing any I/O. If no page tables are needed, I/O memory locations look pretty much like I/O ports, and you can just read and write to them using proper wrapper functions.

Whether or not `ioremap` is required to access I/O memory, direct use of pointers to I/O memory is discouraged. Even though (as introduced in the section “I/O Ports and I/O Memory”) I/O memory is addressed like normal RAM at hardware level, the extra care outlined in the section “I/O Registers and Conventional Memory” suggests avoiding normal pointers. The wrapper functions used to access I/O memory are safe on all platforms and are optimized away whenever straight pointer dereferencing can perform the operation.

Therefore, even though dereferencing a pointer works (for now) on the x86, failure to use the proper macros hinders the portability and readability of the driver.

<h3 id="9.4.1">9.4.1 I/O内存分配和映射 </h3>
***

I/O memory regions must be allocated prior to use. The interface for allocation of memory regions (defined in `<linux/ioport.h>`) is:

    struct resource *request_mem_region(unsigned long start, unsigned long len, char *name);

This function allocates a memory region of `len` bytes, starting at `start`. If all goes well, a non-NULL pointer is returned; otherwise the return value is NULL. All I/O memory allocations are listed in /proc/iomem.

Memory regions should be freed when no longer needed:

    void release_mem_region(unsigned long start, unsigned long len);

There is also an old function for checking I/O memory region availability:

    int check_mem_region(unsigned long start, unsigned long len);

But, as with `check_region`, this function is unsafe and should be avoided.

Allocation of I/O memory is not the only required step before that memory may be accessed. You must also ensure that this I/O memory has been made accessible to the kernel. Getting at I/O memory is not just a matter of dereferencing a pointer; on many systems, I/O memory is not directly accessible in this way at all. So a mapping must be set up first. This is the role of the `ioremap` function, introduced in the section “vmalloc and Friends” in Chapter 1. The function is designed specifically to assign virtual addresses to I/O memory regions.

Once equipped with `ioremap` (and `iounmap`), a device driver can access any I/O memory address, whether or not it is directly mapped to virtual address space. Remember, though, that the addresses returned from `ioremap` should not be dereferenced directly; instead, accessor functions provided by the kernel should be used. Before we get into those functions, we’d better review the `ioremap` prototypes and introduce a few details that we passed over in the previous chapter.

The functions are called according to the following definition:

    #include <asm/io.h>
    void *ioremap(unsigned long phys_addr, unsigned long size);
    void *ioremap_nocache(unsigned long phys_addr, unsigned long size);
    void iounmap(void * addr);

First of all, you notice the new function `ioremap_nocache`. We didn’t cover it in Chapter 8, because its meaning is definitely hardware related. Quoting from one of the kernel headers: “It’s useful if some control registers are in such an area, and write combining or read caching is not desirable.” Actually, the function’s implementation is identical to `ioremap` on most computer platforms: in situations where all of I/O memory is already visible through noncacheable addresses, there’s no reason to implement a separate, noncaching version of ioremap.


<h3 id="9.4.2">9.4.2 Accessing I/O Memory </h3>
***

On some platforms, you may get away with using the return value from `ioremap` as a pointer. Such use is not portable, and, increasingly, the kernel developers have been working to eliminate any such use. The proper way of getting at I/O memory is via a set of functions (defined via `<asm/io.h>`) provided for that purpose.

To read from I/O memory, use one of the following:

    unsigned int ioread8(void *addr);
    unsigned int ioread16(void *addr);
    unsigned int ioread32(void *addr);

Here, `addr` should be an address obtained from `ioremap` (perhaps with an integer offset); the return value is what was read from the given I/O memory.

There is a similar set of functions for writing to I/O memory:

    void iowrite8(u8 value, void *addr);
    void iowrite16(u16 value, void *addr);
    void iowrite32(u32 value, void *addr);

If you must read or write a series of values to a given I/O memory address, you can use the repeating versions of the functions:

    void ioread8_rep(void *addr, void *buf, unsigned long count);
    void ioread16_rep(void *addr, void *buf, unsigned long count);
    void ioread32_rep(void *addr, void *buf, unsigned long count);
    void iowrite8_rep(void *addr, const void *buf, unsigned long count);
    void iowrite16_rep(void *addr, const void *buf, unsigned long count);
    void iowrite32_rep(void *addr, const void *buf, unsigned long count);

These functions read or write `count` values from the given `buf` to the given `addr`. Note that `count` is expressed in the size of the data being written; `ioread32_rep` reads `count` 32-bit values starting at `buf`.

The functions described above perform all I/O to the given addr. If, instead, you need to operate on a block of I/O memory, you can use one of the following:

    void memset_io(void *addr, u8 value, unsigned int count);
    void memcpy_fromio(void *dest, void *source, unsigned int count);
    void memcpy_toio(void *dest, void *source, unsigned int count);

These functions behave like their C library analogs.

If you read through the kernel source, you see many calls to an older set of functions when I/O memory is being used. These functions still work, but their use in new code is discouraged. Among other things, they are less safe because they do not perform the same sort of type checking. Nonetheless, we describe them here:

    unsigned readb(address);
    unsigned readw(address);
    unsigned readl(address);

These macros are used to retrieve 8-bit, 16-bit, and 32-bit data values from I/O memory.

    void writeb(unsigned value, address);
    void writew(unsigned value, address);
    void writel(unsigned value, address);

Like the previous functions, these functions (macros) are used to write 8-bit, 16-bit, and 32-bit data items.

Some 64-bit platforms also offer readq and writeq, for quad-word (8-byte) memory operations on the PCI bus. The quad-word nomenclature is a historical leftover from the times when all real processors had 16-bit words. Actually, the L naming used for 32-bit values has become incorrect too, but renaming everything would confuse things even more.


<h3 id="9.4.3">9.4.3 端口模拟为I/O内存 </h3>
***

Some hardware has an interesting feature: some versions use I/O ports, while others use I/O memory. The registers exported to the processor are the same in either case, but the access method is different. As a way of making life easier for drivers dealing with this kind of hardware, and as a way of minimizing the apparent differences between I/O port and memory accesses, the 2.6 kernel provides a function called `ioport_map`:

    void *ioport_map(unsigned long port, unsigned int count);

This function remaps `count` I/O ports and makes them appear to be I/O memory. From that point thereafter, the driver may use `ioread8` and friends on the returned addresses and forget that it is using I/O ports at all.

This mapping should be undone when it is no longer needed:

    void ioport_unmap(void *addr);

These functions make I/O ports look like memory. Do note, however, that the I/O ports must still be allocated with request_region before they can be remapped in this way.

<h3 id="9.4.4">9.4.4 为I/O重用short </h3>
***

The `short` sample module, introduced earlier to access I/O ports, can be used to access I/O memory as well. To this aim, you must tell it to use I/O memory at load time; also, you need to change the base address to make it point to your I/O region.

For example, this is how we used `short` to light the debug LEDs on a MIPS development board:

    mips.root# ./short_load use_mem=1 base=0xb7ffffc0
    mips.root# echo -n 7 > /dev/short0

Use of `short` for I/O memory is the same as it is for I/O ports.

The following fragment shows the loop used by `short` in writing to a memory location:

    while (count--) {
        iowrite8(*ptr++, address);
        wmb( );
    }

Note the use of a write memory barrier here. Because `iowrite8` likely turns into a direct assignment on many architectures, the memory barrier is needed to ensure that the writes happen in the expected order.

`short` uses `inb` and `outb` to show how that is done. It would be a straightforward exercise for the reader, however, to change `short` to remap I/O ports with `ioport_map`, and simplify the rest of the code considerably.


<h3 id="9.4.5">9.4.5 ISA Memory Below 1 MB </h3>
***

One of the most well-known I/O memory regions is the ISA range found on personal computers. This is the memory range between 640 KB (0xA0000) and 1 MB (0x100000). Therefore, it appears right in the middle of regular system RAM. This positioning may seem a little strange; it is an artifact of a decision made in the early 1980s, when 640 KB of memory seemed like more than anybody would ever be able to use.

This memory range belongs to the non-directly-mapped class of memory.* You can read/write a few bytes in that memory range using the `short` module as explained previously, that is, by setting `use_mem` at load time.

> Actually, this is not completely true. The memory range is so small and so frequently used that the kernel
> builds page tables at boot time to access those addresses. However, the virtual address used to access them
> is not the same as the physical address, and thus ioremap is needed anyway.

Although ISA I/O memory exists only in x86-class computers, we think it’s worth spending a few words and a sample driver on it.

We are not going to discuss PCI memory in this chapter, since it is the cleanest kind of I/O memory: once you know the physical address, you can simply remap and access it. The “problem” with PCI I/O memory is that it doesn’t lend itself to a working example for this chapter, because we can’t know in advance the physical addresses your PCI memory is mapped to, or whether it’s safe to access either of those ranges. We chose to describe the ISA memory range, because it’s both less clean and more suitable to running sample code.

To demonstrate access to ISA memory, we use yet another silly little module (part of the sample sources). In fact, this one is called `silly`, as an acronym for Simple Tool for Unloading and Printing ISA Data, or something like that.

The module supplements the functionality of `short` by giving access to the whole 384-KB memory space and by showing all the different I/O functions. It features four device nodes that perform the same task using different data transfer functions. The `silly` devices act as a window over I/O memory, in a way similar to /dev/mem. You can read and write data, and `lseek` to an arbitrary I/O memory address.

Because `silly` provides access to ISA memory, it must start by mapping the physical ISA addresses into kernel virtual addresses. In the early days of the Linux kernel, one could simply assign a pointer to an ISA address of interest, then dereference it directly. In the modern world, though, we must work with the virtual memory system and remap the memory range first. This mapping is done with `ioremap`, as explained earlier for `short`:

    #define ISA_BASE 0xA0000
    #define ISA_MAX 0x100000 /* for general memory access */
        /* this line appears in silly_init */
        io_base = ioremap(ISA_BASE, ISA_MAX - ISA_BASE);

`ioremap` returns a pointer value that can be used with `ioread8` and the other functions explained in the section “Accessing I/O Memory.”

Let’s look back at our sample module to see how these functions might be used. `/dev/sillyb`, featuring minor number 0, accesses I/O memory with `ioread8` and `iowrite8`. The following code shows the implementation for `read`, which makes the address range 0xA0000-0xFFFFF available as a virtual file in the range 0-0x5FFFF. The `read` function is structured as a switch statement over the different access modes; here is the `sillyb` case:

    case M_8:
        while (count) {
            *ptr = ioread8(add);
            add++;
            count--;
            ptr++;
        }
     break;

The next two devices are `/dev/sillyw` (minor number 1) and /dev/sillyl (minor number 2). They act like /dev/sillyb, except that they use 16-bit and 32-bit functions. Here’s the write implementation of sillyl, again part of a switch:

    case M_32:
        while (count >= 4) {
            iowrite8(*(u32 *)ptr, add);
            add += 4;
            count -= 4;
            ptr += 4;
        }
        break;

The last device is `/dev/sillycp` (minor number 3), which uses the memcpy_*io functions to perform the same task. Here’s the core of its read implementation:

    case M_memcpy:
        memcpy_fromio(ptr, add, count);
        break;

Because `ioremap` was used to provide access to the ISA memory area, `silly` must invoke `iounmap` when the module is unloaded:

    iounmap(io_base);


<h3 id="9.4.6">9.4.6 isa_readb及其辅助函数 </h3>
***

A look at the kernel source will turn up another set of routines with names such as `isa_readb`. In fact, each of the functions just described has an `isa_` equivalent. These functions provide access to ISA memory without the need for a separate `ioremap` step. The word from the kernel developers, however, is that these functions are intended to be temporary driver-porting aids and that they may go away in the future. Therefore, you should avoid using them.
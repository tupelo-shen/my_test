* [7.5 Tasklet](#7.5)
    * [7.6.1 共享队列](#7.6.1)

***
<h2 id="7.5">7.5 Tasklet</h2>
***

关于时间，内核另外一个有力工具就是tasklet机制。它主要用于中断管理。

Tasklet在某些方面与内核定时器类似。它们总是在中断时运行，总是运行在调度它们的CPU上，且能够接受unsigned long类型的参数。又不像内核定时器，不能要求在特定时间执行该功能。通过调度tasklet，你可以让内核选择在稍后的时间执行它。这种行为对于中断处理程序非常有用，硬件中断必须尽可能快的处理，但是数据处理可以延迟后安全地进行。事实上，tasklet，就像内核定时器一样，在“软中断”的上下文中被执行（原子模式），这是内核在使能硬件中断的情况下执行异步任务的一种机制。

A tasklet exists as a data structure that must be initialized before use. Initialization can be performed by calling a specific function or by declaring the structure using certain macros:

    #include <linux/interrupt.h>
    struct tasklet_struct {
        /* ... */
        void (*func)(unsigned long);
        unsigned long data;
    };

    void tasklet_init(struct tasklet_struct *t, void (*func)(unsigned long), unsigned long data);
    DECLARE_TASKLET(name, func, data);
    DECLARE_TASKLET_DISABLED(name, func, data);

Tasklets offer a number of interesting features:

* A tasklet can be disabled and re-enabled later; it won’t be executed until it is enabled as many times as it has been disabled.
* Just like timers, a tasklet can reregister itself.
* A tasklet can be scheduled to execute at normal priority or high priority. The latter group is always executed first.
* Tasklets may be run immediately if the system is not under heavy load but never later than the next timer tick.
* A tasklets can be concurrent with other tasklets but is strictly serialized with respect to itself—the same tasklet never runs simultaneously on more than one processor. Also, as already noted, a tasklet always runs on the same CPU that schedules it.

The jit module includes two files, /proc/jitasklet and /proc/jitasklethi, that return the same data as /proc/jitimer, introduced in the section “Kernel Timers.” When you read one of the files, you get back a header and sixdata lines. The first data line describes the context of the calling process, and the other lines describe the context of successive runs of a tasklet procedure. This is a sample run while compiling a kernel:

    phon% cat /proc/jitasklet
     time delta inirq pid cpu command
     6076139 0 0 4370 0 cat
     6076140 1 1 4368 0 cc1
     6076141 1 1 4368 0 cc1
     6076141 0 1 2 0 ksoftirqd/0
     6076141 0 1 2 0 ksoftirqd/0
     6076141 0 1 2 0 ksoftirqd/0

As confirmed by the above data, the tasklet is run at the next timer tick as long as the CPU is busy running a process, but it is run immediately when the CPU is otherwise idle. The kernel provides a set of ksoftirqd kernel threads, one per CPU, just to run “soft interrupt” handlers, such as the tasklet_action function. Thus, the final three runs of the tasklet take place in the context of the ksoftirqd kernel thread associated to CPU 0. The jitasklethi implementation uses a high-priority tasklet, explained in an upcoming list of functions.

The actual code in jit that implements /proc/jitasklet and /proc/jitasklethi is almost identical to the code that implements /proc/jitimer, but it uses the tasklet calls instead of the timer ones. The following list lays out in detail the kernel interface to tasklets after the tasklet structure has been initialized:

*void tasklet_disable(struct tasklet_struct *t);

    This function disables the given tasklet. The tasklet may still be scheduled with tasklet_schedule, but its execution is deferred until the tasklet has been enabled again. If the tasklet is currently running, this function busy-waits until the tasklet exits; thus, after calling tasklet_disable, you can be sure that the tasklet is not running anywhere in the system.

* void tasklet_disable_nosync(struct tasklet_struct *t);

    Disable the tasklet, but without waiting for any currently-running function to exit. When it returns, the tasklet is disabled and won’t be scheduled in the future until re-enabled, but it may be still running on another CPU when the function returns.

* void tasklet_enable(struct tasklet_struct *t);

    Enables a tasklet that had been previously disabled. If the tasklet has already been scheduled, it will run soon. A call to tasklet_enable must match each call to tasklet_disable, as the kernel keeps track of the “disable count” for each tasklet.

* void tasklet_schedule(struct tasklet_struct *t);

    Schedule the tasklet for execution. If a tasklet is scheduled again before it has a chance to run, it runs only once. However, if it is scheduled while it runs, it runs again after it completes; this ensures that events occurring while other events are being processed receive due attention. This behavior also allows a tasklet to reschedule itself.

* void tasklet_hi_schedule(struct tasklet_struct *t);

    Schedule the tasklet for execution with higher priority. When the soft interrupt handler runs, it deals with high-priority tasklets before other soft interrupt tasks, including “normal” tasklets. Ideally, only tasks with low-latency requirements (such as filling the audio buffer) should use this function, to avoid the additional latencies introduced by other soft interrupt handlers. Actually, /proc/jitasklethi shows no human-visible difference from /proc/jitasklet.

* void tasklet_kill(struct tasklet_struct *t);

    This function ensures that the tasklet is not scheduled to run again; it is usually called when a device is being closed or the module removed. If the tasklet is scheduled to run, the function waits until it has executed. If the tasklet reschedules itself, you must prevent it from rescheduling itself before calling tasklet_kill, as with del_timer_sync.

Tasklets are implemented in kernel/softirq.c. The two tasklet lists (normal and highpriority) are declared as per-CPU data structures, using the same CPU-affinity mechanism used by kernel timers. The data structure used in tasklet management is a simple linked list, because tasklets have none of the sorting requirements of kernel timers.


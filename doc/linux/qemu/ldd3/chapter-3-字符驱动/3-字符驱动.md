<h1 id="0">0 目录</h1>

* [3.1 scull设计](#3.1)
* [3.2 主次设备号](#3.2)
    - [3.2.1 设备号的内部表示](#3.2.1)
    - [3.2.2 分配和释放设备号](#3.2.2)
* [3.3 内核模块和应用程序](#3.3)
    - [3.3.1 用户空间和内核空间](#3.3.1)
    - [3.3.2 内核中的并发处理](#3.3.2)
    - [3.3.3 当前进程](#3.3.3)
    - [3.3.4 其它细节](#3.3.4)
* [3.4 编译和加载](#3.4)
    - [3.4.1 编译模块](#3.4.1)
    - [3.4.2 加载和卸载模块](#3.4.2)

---

本章的目的就是编写一个完整的字符设备驱动程序。我们选择字符设备驱动程序，是因为大多数简单的硬件设备都属于这一类。字符设备驱动程序相比块设备和网络设备要更容易理解（后面的章节我们再讨论其它的设备）。最终我们会编写一个模块化的字符驱动程序，但是并没有讨论模块性的问题。

纵观本章，我们从实际的设备抽象出了这段代码：scull（简单的字符设备工具）。Scull是一个作用于内存区域上的字符设备驱动程序。我们可以这样理解，scull所使用的内存区域就是一个设备。

Scull的优点就是不依赖硬件，它只需要占用内核分配的一些内存即可。任何人都可以编译、运行在linux系统之上。除了演示内核和字符驱动程序之间的接口并允许用户做一些测试之外，该设备不会执行任何其它有用的操作。


<h2 id="3.1">3.1 scull设计</h2>

驱动程序编写的第一步是定义驱动程序为用户程序提供的功能（机制）。由于我们的“设备”是计算机内存的一部分，因此我们可以自由地按照自己的意愿去做。它可以是顺序或随机访问设备，也可以是一个或多个设备，等等。

为了让scull成为编写真实设备、真实驱动程序的模板，我们将向您展示如何在计算机内存上实现多个设备抽象，每个设备抽象具有不同的个性。

scull源代码实现以下几种设备。 模块实现的每一种设备归为一类。

* scull0~scull3

    4个设备，每个设备都包含一个全局、永久的内存区域。全局意味着如果设备被多次打开，设备中包含的数据将被打开它的所有文件描述符共享。持久意味着如果设备关闭并重新打开，数据不会丢失。使用这些设备非常有趣，因为可以使用常见命令，如 **cp**，**cat** 和 **shell I/O重定向** 进行访问和测试。

* scullpipe0~scullpipe3

    4个 *FIFO*（先进先出）设备，就像管道一样。一个进程读取，另一个进程写入。如果多个进程读取相同的设备，会产生数据竞争。*scullpipe* 的内部将展示，如何实现阻塞和非阻塞读写，而不必求助于中断。 虽然真正的驱动程序使用硬件中断与其设备同步， 但是阻塞和非阻塞操作的内容也非常重要，与中断处理是分开学习。

* scullsingle、scullpriv、sculluid、scullwuid

    这些设备与scull0类似，但在打开时有一些限制。第一个（scullsingle）每次只允许一个进程使用驱动程序，而scullpriv对于每个虚拟控制台（或X终端会话）是私有的，因为每个控制台/终端上的进程获得不同的内存区域。sculluid和scullwuid可以多次打开，但一次只能由一个用户打开;如果另一个用户正在锁定设备，则前者返回“设备忙”的错误，而后者实现阻止打开。这些变种的scull似乎是混淆策略和机制，但值得关注，因为一些现实生活中的设备需要这种管理。

每个scull设备都展示了驱动程序的不同特征，表现出了不同的难度。本章涵盖了scull0到scull3的内部结构；关于更高级的设备在第6章中介绍。有关scullpipe的信息，请参见“一个阻塞I/O的例子”一节，其它的在“设备文件的访问控制”中进行了介绍。

<h2 id="3.2">3.2 主次设备号</h2>

字符设备通过文件系统中的名称进行访问。这些名称被称为特殊文件或设备文件或简称为文件系统树的节点;它们通常位于 */dev*目录中。字符驱动程序的特殊文件由 *ls -l*输出的第一列中的“*c*”标识。块设备也出现在 */dev*中，但是它们由“*b*”标识。本章的焦点在字符设备上，但以下大多数信息也适用于块设备。
如果键入 *ls -l*命令，则会在上次修改日期之前的设备文件项中看到两个数字（用逗号分隔），其中文件长度通常出现在该处。这些数字是特定设备的主要和次要设备号。以下列表显示了一些典型系统上显示的设备。它们的主要设备号是1,4,7和10，而次要设备号是1,3,5,64,65和129。

    crw-rw-rw- 1 root root  1,  3   Apr 11 2002 null
    crw------- 1 root root  10, 1   Apr 11 2002 psaux
    crw------- 1 root root  4,  1   Oct 28 03:04 tty1
    crw-rw-rw- 1 root tty   4,  64  Apr 11 2002 ttys0
    crw-rw---- 1 root uucp  4,  65  Apr 11 2002 ttyS1
    crw--w---- 1 vcsa tty   7,  1   Apr 11 2002 vcs1
    crw--w---- 1 vcsa tty   7,  129 Apr 11 2002 vcsa1
    crw-rw-rw- 1 root root  1,  5   Apr 11 2002 zero

传统上，主设备号标识与设备关联的驱动程序。例如，/dev/null和/dev/zero都由驱动程序1管理，而虚拟控制台和串行终端由驱动程序4管理；类似地，vcs1和vcsa1设备都由驱动程序7管理。现代Linux内核允许多个驱动程序共享主设备号，但您将看到的大多数设备仍然按照 *一一对应*原则组织。

内核使用次设备号来确定究竟哪个设备被引用。根据驱动程序的写法（如下面所示），您可以从内核获取指向设备的直接指针，也可以使用次要编号作为本地设备阵列的索引。无论哪种方式，内核本身除了知道它们引用的是驱动程序实现的设备之外，对其它一无所知。

<h3 id="3.2.1">3.2.1 设备号的内部表示</h3>

在内核中，*dev_t* （位于 *linux/types.h* 头文件中）用于保存设备号-主、次设备号。从内核版本2.6.0开始，*dev_t* 是一个32位数， 主设备号为12位，次设备号为20。我们应该使用 *linux/kdev_t.h* 中的一组宏来操作主、次设备号。如下：

    MAJOR(dev_t dev);
    MINOR(dev_t dev);

反过来，把主次设备号转换成 *dev_t* 型的数据，请使用：

    MKDEV(int major, int minor);

<h3 id="3.2.2">3.2.2 分配和释放设备号</h3>

在注册字符设备时，驱动程序需要做的第一件事就是获取设备号。要调用的函数就是 *register_chrdev_region*，其声明位于 *linux/fs.h* 文件中：

    int register_chrdev_region(dev_t first, unsigned int count, char *name);

函数参数说明：

* first

    是想要分配的设备号范围的起始位置；first的次要设备号通常是0，但没有要求。

* count

    是请求的连续设备号的总数。请注意，如果count很大，您请求的范围可能会溢出到下一个主要设备号；但只要请求的号码范围可用，所有内容仍将正常工作。

* name

    是应该与此号码范围关联的设备的名称；它会出现在 */proc/devices* 和 *sysfs* 中。

与大多数内核函数一样，如果分配成功执行，*register_chrdev_region* 的返回值将为0。 如果发生错误， 将返回一个负数的错误代码， 并且将无法访问请求的区域。

如果您事先知道所需的设备号， *register_chrdev_region* 可以很好地工作。但是，通常情况下，不会知道设备将使用哪些主设备号；Linux内核开发社区一直在努力转向使用动态分配的设备编号。内核会快速地为设备分配一个主设备号，但必须使用不同的函数来请求：

    int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name);

使用此函数，*dev* 是一个只输出的参数，在成功完成时，将保留分配范围中的第一个数字。 *firstminor*应该是请求的第一个次设备号； 它通常是0。*count* 和 *name* 参数与 *request_chrdev_region* 的参数一样。

但是，无论如何分配设备号，不再使用时都应该释放它们。设备号释放函数：

    void unregister_chrdev_region(dev_t first, unsigned int count);

调用 *unregister_chrdev_region* 的通常位置是在模块的清理函数中。

上述函数为驱动程序分配设备号，但它们不会告诉内核使用这些设备号做什么。在用户空间程序访问其中一个设备号之前，驱动程序需要将它们连接到实现设备操作的内部函数。我们将尽快描述这种连接是如何完成的，但首先需要处理几个其它的问题。

<h3 id="3.2.3">3.2.3 主设备号的动态分配</h3>

一些主设备号被静态地分配给最常用的设备了。这些设备的列表可以在内核源码树中的 *Documentation/devices.txt* 中找到。作为一名驱动开发者，你可以简单地选择一个似乎未被使用的设备号，或者可以动态地分配主设备号。如果驱动程序的唯一用户是自己，选择一个号码就可以工作；一旦驱动程序被广泛地部署，随机挑选的主设备号将导致冲突和麻烦。

因此，对于新的驱动程序，我们强烈建议使用动态分配来获取主设备号，而不是随机选择一个号。换句话说，驱动程序尽量使用 *alloc_chrdev_region* 而不是 *register_chrdev_region*。动态分配的缺点是无法预先创建设备节点，因为分配给模块的主设备号会有所不同。对于驱动程序的正常使用，这不是一个问题，因为一旦分配了编号，就可以从 */proc/devices* 中读取它。

当然了，分配主设备号的最好办法就是，默认动态分配，但可以在编译或者加载模块的时候手动指定主设备号。*scull* 模块的代码使用一个全局 变量 *scull_major* 来保存设定的主设备号（使用 *scull_minor* 保存次设备号）。该变量在 *scull.h* 中定义，初始化为 *SCULL_MAJOR*。源代码中 *SCULL_MAJOR*的缺省值为 *0*，这意味着“使用动态分配”。除此之外，用户可以接受默认值或选择特定的主设备号， 也可以通过在编译前修改宏或在 **insmod**中指定 *scull_major*的值。还可以使用 *scull_load*脚本，通过命令行参数传递给 *insmod*。

在我们看来，分配主设备号的最好方法是默认动态分配，同时让你自己可以选择在加载时或编译时指定主设备号。scull实现以这种方式工作；它使用一个全局变量scull_major来保存选定的主设备号（对于次设备号也有一个scull_minor）。该变量在scull.h中定义，初始化为SCULL_MAJOR。源代码中SCULL_MAJOR的缺省值为0，这意味着“使用动态分配”。用户可以接受缺省值或选择特定的主设备号，可以通过在编译前修改宏或在insmod中指定scull_major的值。最后，通过使用scull_load脚本，用户可以在scull_load的命令行上将参数传递给insmod。
以下是我们在scull源代码中使用的代码，以获得一个主设备号：

    if (scull_major) {
        dev = MKDEV(scull_major, scull_minor);
        result = register_chrdev_region(dev, scull_nr_devs, "scull");
    } else {
        result = alloc_chrdev_region(&dev, scull_minor, scull_nr_devs, "scull");
        scull_major = MAJOR(dev);
    }
    if (result < 0) {
        printk(KERN_WARNING "scull: can't get major %d\n", scull_major);
        return result;
    }

本书中几乎所有使用的示例驱动程序都使用类似的代码来进行主设备号的分配。


<div style="text-align: right"><a href="#0">回到顶部</a><a name="_label0"></a></div>

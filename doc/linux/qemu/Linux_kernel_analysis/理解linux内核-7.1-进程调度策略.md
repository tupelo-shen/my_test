[TOC]

## 1 前提条件

本文假设平台是x86架构，采用统一内存访问模型（UMA），系统TICK设置为1ms。

## 2 什么是调度策略

调度策略是确定何时、如何选择一个进程运行在CPU上的机制。一个优秀的调度算法必须满足几个目标条件：快速的进程响应时间、后台任务良好的吞吐率，避免`饥饿`进程的产生，不同优先级进程的平衡等等。但是，这些目标本质上是冲突的，所以，如何平衡这些需求成为衡量一个调度算法的重要指标。

## 3 Linux调度策略

Linux进程调度基于时间共享技术：将CPU的时间平等地划分为许多时间片，每个时间片对应一个进程，多个进程共享这些时间片，这被称为`时间复用`技术。当然了，单核处理器一次只能运行一个进程。如果时间片或进程运行到时而运行中的进程没有被终止，就会发生进程切换。时间片共享技术依赖于定时器中断，对于进程来说是透明的。

> 值得注意的是，调度算法不涉及已经停止（进程状态为stopped）和挂起的进程（进程状态为suspended）。

影响调度策略的另外一个重要维度就是进程优先级。每个进程都会被绑定一个优先级值，调度器根据优先级大小的顺序确定运行在CPU上的进程顺序。

总结来说，<font color="blue">Linux的调度策略就是基于时间片轮转的可抢占式内核调度策略。</font>

Linux中，进程优先级是动态的。调度器会追踪进程运行状态，并据此调整其优先级。如果某些进程长时间得不到调度执行，Linux内核会通过增加其优先级而加快这些进程的执行；相应地，如果进程长时间占据CPU时间，调低其优先级，暂缓其执行。

## 4 Linux进程分类

通常谈及调度时，会把进程分为两大类，I/O类进程和CPU类进程。前者强依赖于与I/O设备的通信，需要等待I/O操作完成；后者需要大量的CPU执行时间。

另外一种分类方法是

* 交互式进程

    这类进程一般需要与用户频繁交互，因此，需要花费大量的时间等待按键事件和鼠标操作。一旦接收到输入，进程必须快速唤醒，否则用户感受到系统没有产生响应。通常，这个时间延时平均在50~150ms之间。典型的交互程序是命令行，文本编辑器和图形应用程序。

* 批处理进程

    不需要用户交互，一般运行在后台。典型的批处理程序包括编译器、数据库搜索引擎、和科学计算程序等。

* 实时进程
    
    这类进程一般有着严格的调度要求。进程不应该被低优先级进程阻塞，应该具有一个可靠的最小响应时间。典型的实时程序包括：音视频应用程序、机器人控制器、收集传感器数据的程序等。

上面列举的两种分类方法某种程度上是独立的，批处理程序既可以是I/O类进程（比如数据库服务器），也可以是CPU类进程（比如图形渲染程序）。对于实时程序，Linux内核的调度算法很好区分，但是却没有简单的方法区分交互式、批处理程序。Linux 2.6内核调度器探索式的推出了一种复杂算法，基于进程过去的行为，从而决定给定进程是属于交互式还是批处理程序。当然了，调度器倾向于交互式进程而非批处理进程。

这儿我们之所以讨论进程的分类，是因为进程的优先级是根据其行为设定的：一般情况下，优先级的排列顺序是`实时进程>交互式进程>批处理进程`。

## 5 Linux跟调度相关的系统调用

表7-1. 跟调度相关的系统调用

| 系统调用 | 描述 |
| -------- | ---- |
| nice                      | 更改常规进程的静态优先级 |
| getpriority()             | 获取一组常规进程的最大静态优先级 |
| setpriority()             | 设置一组常规进程的静态优先级 |
| sched_getscheduler()      | 获取某个进程的调度策略 |
| sched_setscheduler()      | 设置某个进程的调度策略和实时优先级 |
| sched_getparam()          | 获取某个进程的实时优先级 |
| sched_setparam()          | 设置某个进程的实时优先级 |
| sched_yield()             | 自愿放弃CPU的使用权而不会产生阻塞 |
| sched_get_priority_min()  | 获取调度策略中的最小实时优先级值 |
| sched_get_priority_max()  | 获取调度策略中的最大实时优先级值 |
| sched_rr_get_interval()   | 获取循环策略的时间片间隔 |
| sched_setaffinity()       | 设置进程的CPU亲和力掩码 |
| sched_getaffinity()       | 获取进程的CPU亲和力掩码 |

## 6 进程抢占

其实，我们都知道Linux内核是一个可抢占式内核。当进程A进入`TASK_RUNNING`运行态时，内核会把进程A的动态优先级与当前正在运行的进程B的优先级进行比较。如果进程A大于进程B，那么进程B的运行就会被中断，而调度器会调用进程A运行（进程A会立即进入可运行态）。另一种抢占情况就是，进程的单次执行生命周期到了。此时，当前进程记录进程状态的数据结构`thread_info`中的`TIF_NEED_RESCHED`标志就会被设置，在下一个定时器中断到来时，会调用调度器，选择一个新的合适的进程执行。

我们考虑这样一种场景：只有两个进程正在执行，一个是文本编辑器；另一个是编译器。文本编辑器具有更高的动态优先级。但是，用户不可能一直在输入，他需要思考。所以，文本编辑器经常需要挂起，而且按键之间的延时也是很长的。但是，只要用户一旦键入，输入中断就会立即产生，从而唤醒文本编辑器进程。内核知道，文本编辑器的动态优先级高于当前正在运行的进程（编译器）的优先级。所以，设置编译器进程的标志位`TIF_NEED_RESCHED`，当内核完成中断处理后，强制调用调度器。调度器会选择文本编辑器并执行进程切换。文本编辑器会迅速恢复执行，用户键入的字符就会被回显到屏幕上。处理完字符后，文本编辑器进程把自身挂起，等待用户下一次的按键输入。而此时，编译器会被恢复执行。

需要注意的是，被抢占的进程不会挂起，仍然处于`TASK_RUNNING`状态；仅仅不再使用CPU而已。

Be aware that a preempted process is not suspended, because it remains in the TASK_RUNNING state; it simply no longer uses the CPU. Moreover, remember that the Linux 2.6 kernel is preemptive, which means that a process can be preempted either when executing in Kernel or in User Mode; we discussed in depth this feature in the section “Kernel Preemption” in Chapter 5.

## 7 如何设计进程的执行时间最为合适？

进程的单次运行生命周期对于系统性能是至关重要的：不宜太长，也不宜太短。

如果进程的平均单次生命周期太短，由于进程切换造成的系统负荷会很重。我们举一个极端的例子：假设进程切换需要5mS的时间（实际系统一般远远小于该值，有的嵌入式系统甚至小于0.1uS）；而进程的单次生命周期也需要5mS，那么至少一半的CPU时间周期被进程切换消耗掉了。

如果进程的单次生命周期过长，进程的并发性就会受到影响。假设进程的单次生命周期为5S，每个可运行的进程占用CPU的时间就是5S，那么它的停止时间就会相当长（通常，等于5S乘以可运行进程的个数）。

根据上述结论，较长的单次进程生命周期会降低交互式应用程序的响应时间。但这个结论通常是错误的。我们前面提到过，一般情况下，交互式程序一般具有相对较高的优先级，可以快速地抢占`批处理进程`的CPU使用权，而不关心`批处理进程`的单次生命周期是多长。

但是，事无绝对。有些时候，单次生命周期过长的进程也会降低系统的响应性。假设，两个用户同时往自己的shell命令行敲入命令，启动某个后台任务：用户A启动了一个运算任务很重（占用CPU时间长）的进程，另一个用户B启动了交互式程序；并且假设两个进程都有相同的初始优先级（Linux事先并不知道哪个是批处理类型进程，哪个是交互式进程）。如果调度器选择先运行用户A启动的进程，用户B启动的进程就会等待很长时间才能执行。因此，如果进程的单次生命周期过长，对于用户B而言，其交互式程序就像没有响应一样。

所以说，进程的单次生命周期的平均时间就是一个折中妥协的产物。Linux的经验法则就是，在保持良好系统响应特性的情况下，使用尽可能长的进程单次生命周期。

## 8 学习总结


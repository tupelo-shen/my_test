<h1 id="0">0 目录</h1>

* [1 寄存器分类](#1)
* [2 通用寄存器](#2)
* [3 状态寄存器](#3)
* [4 段寄存器](#4)
* [5 控制寄存器](#5)
* [6 调试寄存器](#6)
* [7 系统地址寄存器](#7)
* [8 其它寄存器](#8)

---

<h2 id="1">1 寄存器分类</h2> 

1. 8个通用寄存器：EAX、EBX、ECX、EDX、ESI、EDI、ESP、EBP

2. 1个标志寄存器：EFLAGS

3. 6个段寄存器：CS、DS、ES、FS、GS、SS

4. 5个控制寄存器：CR0、CR1、CR2、CR3、CR4

5. 8个调试寄存器：DR0、DR1、DR2、DR3、DR4、DR5、DR6、DR7

6. 4个系统地址寄存器：GDTR、IDTR、LDTR、TR

7. 其他寄存器：EIP、TSC等。

<h2 id="2">2 通用寄存器</h2> 

| 32位 | 16位 | 8位 |
| ---- | ---- | ---- |
| EAX  | AX   | AH、AL |
| EBX  | BX   | BH、BL |
| ECX  | CX   | CH、CL |
| EDX  | DX   | DH、DL |
| ESI  | SI   | --     |
| EDI  | DI   | --     |
| ESP  | SP   | --     |
| EBP  | BP   | --     |

如上表，有8个通用寄存器，且其中的16位寄存器并没有专门分配硬件，而是与32位寄存器通用来实现。在32位CPU中，其32位寄存器EAX、EBX、ECX和EDX不仅可传送数据、暂存数据保存算术逻辑运算结果，而且也可作为指针寄存器，所以，这些32位寄存器相比16位CPU中的AX、BX、CX、DX更具有通用性。

1. EAX
    
    累加器(Accumulator), 它的低16位即是AX，而AX又可分为高8位AH和低8位AL。EAX是很多加法乘法的缺省寄存器，存放函数的返回值，用累加器进行的操作可能需要更少时间，在80386及其以上的微处理器中可以用来存放存储单元的偏移地址。AX寄存器是算术运算的主要寄存器。

2. EBX 
    
    基地址寄存器（Base Register），它的低16位即是BX，而BX又可分为高8位BH和低8位BL。主要用于在内存寻址时存放基地址。

3. ECX
    
    计数寄存器（Count Register），它的低16位即是CX，而CX又可分为高8位CH和低8位CL。在循环和字符串操作时，要用它来控制循环次数；在位操作中，当移多位时，要用CL来指明移位的位数；是重复(REP)前缀指令和LOOP指令的内定计数器。

4. EDX

    数据寄存器（Data Register），它的低16位即是DX，而DX又可分为高8位DH和低8位DL。在进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I/O的端口地址；且总是被用来放整数除法产生的余数。

5. ESI/EDI
    
    分别叫做源/目标索引寄存器(Source/Destination Index Register)，它们的低16位分别是SI、DI。它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。在很多字符串操作指令中, DS:ESI指向源串,而ES:EDI指向目标串。此外，它们又作为通用寄存器可以进行任意的常规的操作，如加减移位或普通的内存间接寻址。

6. EBP/BSP
    
    分别是基址指针寄存器（Base Pointer Register）/堆栈指针寄存器（Stack Pointer Register），低16位是BP、SP，其内存分别放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶/底部。主要用于存放堆栈内存储单元的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。指针寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。并且规定：BP为基指针(Base Pointer)寄存器，用它可直接存取堆栈中的数据；SP为堆栈指针(Stack Pointer)寄存器，用它只可访问栈顶。在32位平台上，ESP每次减少4字节。EBP最经常被用作高级语言函数调用的"栈帧指针"（frame pointer）,EBP 构成了函数的一个栈帧，在C++反汇编中EBP通常是局部变量、传进来的参数。这里要注意在intel系统中栈是向下生长的(栈越扩大其值越小,堆恰好相反)。在通常情况下ESP是可变的,随着栈的生长而逐渐变小,而ESB寄存器是固定的,只有当函数的调用后,发生入栈操作而改变，在函数执行结束之后需要还原。
 
<h2 id="3">3 状态寄存器</h2> 

EFLAGS属于状态寄存器，它们对程序地执行至关重要。

**EFLAGS：**主要用于提供程序的状态及进行相应的控制。32位的EFLAGS寄存器包含一组状态标志、系统标志以及一个控制标志。在x86处理器初始化之后，EFLAGS寄存器的状态值为0000 0002H。第1、3、5、15以及22到31位均被保留，这个寄存器中的有些标志通过使用特殊的通用指令可以直接被修改，但并没有指令能够检查或者修改整个寄存器。通过使用LAHF/SAHF/PUSHF/POPF/POPFD等指令，可以将EFLAGS寄存器的标志位成组移到程序栈或EAX寄存器，或者从这些设施中将操作后的结果保存到EFLAGS寄存器中。在EFLAGS寄存器的内容被传送到栈或是EAX寄存器后，可以通过位操作指令(BT,BTS, BTR, BTC)检查或修改这些标志位。当调用中断或异常处理程序时，处理器将在程序栈上自动保存EFLAGS的状态值。若在中断或异常处理时发生任务切换，那么EFLAGS寄存器的状态将被保存在TSS中，注意是将要被挂起的本次任务的状态。

### 状态标志(Status Flags)

EFLAGS寄存器的状态标志(0、2、4、6、7以及11位)是指示算术指令（如ADD, SUB, MUL以及DIV指令）的结果，这些状态标志的作用如下：

1. CF(bit 0) [Carry flag]()
    
    若算术操作产生的结果在最高有效位(most-significant bit)发生进位或借位则将其置1，反之清零。这个标志指示无符号整型运算的溢出状态，这个标志同样在多倍精度运算(multiple-precision arithmetic)中使用。

2. PF(bit 2) [Parity flag]()
    
    如果结果的最低有效字节(least-significant byte)包含偶数个1位则该位置1，否则清零。

3. AF(bit 4) [Adjust flag]()
   
    如果算术操作在结果的第3位发生进位或借位则将该标志置1，否则清零。这个标志在BCD(binary-code decimal)算术运算中被使用。

4. ZF(bit 6) [Zero flag]()
    
    若结果为0则将其置1，反之清零。

5. SF(bit 7) [Sign flag]()
    
    该标志被设置为有符号整型的最高有效位。(0指示结果为正，反之则为负)

6. OF(bit 11) [Overflow flag]()
    
    如果整型结果是较大的正数或较小的负数，并且无法匹配目的操作数时将该位置1，反之清零。这个标志为带符号整型运算指示溢出状态。

在这些状态标志中，只有CF标志能够通过使用STC, CLC以及CMC指令被直接修改，或者通过位指令(BT, BTS, BTR以及BTC)将指定的位拷贝至CF标志中。

这些状态标志允许单个的算术操作产生三种不同数据类型的结果：无符号整型，有符号整型以及BCD整型。如果把该结果当做无符号整型，那么CF标志指示越界(out-of-range)状态——即进位或借位，如果被当做有符号整型，则OF标志指示进位或借位，若作为BCD数，那么AF标志指示进位或借位。SF标志指示有符号整数的符号位，ZF指示结果为零。此外在执行多倍精度算术运算时，CF标志用来将一次运算过程中带进位的加法(ADC)或带借位的减法(SBB)产生的进位或借位传递到下一次运算过程中。

### 控制标志(DF flag)

1. DF(bit10)[Direction flag]() 
    
    控制串指令(MOVS, CMPS, SCAS, LODS以及STOS)。设置DF标志使得串指令自动递减（从高地址向低地址方向处理字符串），清除该标志则使得串指令自动递增。STD以及CLD指令分别用于设置以及清除DF标志。

### 系统标志以及IOPL域(System Flags and IOPL Field)

EFLAGS寄存器中的这部分标志用于控制操作系统或是执行操作，它们不允许被应用程序所修改。这些标志的作用如下：

1. TF(bit 8) [Trap flag]()
    
    将该位设置为1以允许单步调试模式，清零则禁用该模式。

2. IF(bit 9)[Interrupt enable flag]()

    该标志用于控制处理器对可屏蔽中断请求(maskable interrupt requests)的响应。置1以响应可屏蔽中断，反之则禁止可屏蔽中断。

3. IOPL(bits 12 and 13) [I/O privilege level field]()
    
    指示当前运行任务的I/O特权级(I/O privilege level)，正在运行任务的当前特权级(CPL)必须小于或等于I/O特权级才能允许访问I/O地址空间。这个域只能在CPL为0时才能通过POPF以及IRET指令修改。

4. NT(bit 14) [Nested task flag]()
    
    这个标志控制中断链和被调用任务。若当前任务与前一个执行任务相关则置1，反之则清零。

5. RF(bit 16) [Resume flag]()
    
    控制处理器对调试异常的响应。

6. VM(bit 17) [Virtual-8086 mode flag]()
    
    置1以允许虚拟8086模式，清除则返回保护模式。

7. AC(bit 18) [Alignment check flag]
    
    该标志以及在CR0寄存器中的AM位置1时将允许内存引用的对齐检查，以上两个标志中至少有一个被清零则禁用对齐检查。

8. VIF(bit 19) [Virtual interrupt flag]()
    
    该标志是IF标志的虚拟镜像(Virtual image)，与VIP标志结合起来使用。使用这个标志以及VIP标志，并设置CR4控制寄存器中的VME标志就可以允许虚拟模式扩展(virtual mode extensions)

9. VIP(bit 20) [Virtual interrupt pending flag]()
    
    该位置1以指示一个中断正在被挂起，当没有中断挂起时该位清零。与VIF标志结合使用。

10. ID(bit 21) [Identification flag]()

    程序能够设置或清除这个标志指示了处理器对CPUID指令的支持。

<h2 id="4">4 段寄存器</h2>

段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址，x86的段寄存器有6个----CS/DS/ES/SS/FS/GS，均为16位。

1. CS

    CS段寄存器包含代码段的段选择符，代码段保存正在执行的指令。处理器从代码段读取指令时，使用有CS寄存器中的段选择符与EIP寄存器联合构成的逻辑地址。EIP保存要执行的下一条指令在代码段中的偏移量。CS寄存器不能有应用程序显式地的加载。相反，可以通过某些指令或处理器内部操作隐式地加载。这些指令/内部操作，例如过程调用，中断处理，或者任务切换，用于改变程序的执行流，从而导致更新CS寄存器。

2. DS/ES/FS/GS

    这四个寄存器指向四个数据段。多个数据段的存在允许高效地且安全地访问不同的数据结构类型。例如，可以创建如下的四个数据段：第一个数据段保存当前程序模块的数据结构，第二个数据段保存更高级别程序模块导出的数据，第三个数据段保存动态创建的数据结构，最后一个数据段保存另一个程序共享出来的数据。要想访问更多的数据段，应用程序必须按需将数据段对应的段选择符加载到DS/ES/FS/GS寄存器中的其中一个当中。

3. SS
    
    SS寄存器包含栈段的段选择符，这里栈段用于存储程序/任务/当前正在执行的处理器程序的栈帧。所有的栈操作都使用SS栈段寄存器来定位栈段。与CS代码段寄存器不同，SS寄存器可以显式地加载，这样就允许应用程序建立多个栈段，并在这些段间切换。

<h2 id="5">5 控制寄存器</h2>

X86提供了控制寄存器，来决定CPU的操作模式和当前执行的任务的属性。有4个控制寄存器：CR0、CR1、CR2、CR3；均为32位，用于控制和确定处理器的操作模式以及当前执行任务的特性，保存全局性和任务无关的机器状态。这几个寄存器是与分页机制密切相关的，因此，在进程管理及虚拟内存管理中会涉及到这几个寄存器。对控制寄存器的读写是通过mov指令来实现。

1. CR0：包含6个预定义标志，分为协处理器控制位和保护控制位两类：
    
    1. CR0中协处理器控制位：

        CR0的4个位：扩展类型位ET、任务切换位TS、仿真位EM和数学存在位MP用于控制80x86浮点（数学）协处理器的操作。CR0的ET位（标志）用于选择与协处理器进行通信所使用的协议，即指明系统中使用的是80387还是80287协处理器。TS、MP和EM位用于确定浮点指令或WAIT指令是否应该产生一个设备不存在（Device Not Available，DNA）异常。这个异常可用来仅为使用浮点运算的任务保存和恢复浮点寄存器。对于没有使用浮点运算的任务，这样做可以加快它们之间的切换操作。

        1. ET 
            
            CR0的位4是扩展类型（Extension Type）标志。当该标志为1时，表示指明系统中有80387协处理器，并使用32位协处理器协议。ET=0指明使用80287协处理器。如果仿真位EM=1，则该位将被忽略。在处理器复位操作时，ET位会被初始化指明系统中使用的协处理器类型。如果系统中有80387，则ET被设置成1，否则若有一个80287或者没有协处理器，则ET被设置成0。
        
        2. TS 
            
            CR0的位3是任务已切换（Task Switched）标志。该标志用于推迟保存任务切换时的协处理器内容，直到新任务开始实际执行协处理器指令。处理器在每次任务切换时都会设置该标志，并且在执行协处理器指令时测试该标志。如果设置了TS标志并且CR0的EM标志为0，那么在执行任何协处理器指令之前会产生一个设备不存在异常。如果设置了TS标志但没有设置CR0的MP和EM标志，那么在执行协处理器指令WAIT/FWAIT之前不会产生设备不存在异常。如果设置了EM标志，那么TS标志对协处理器指令的执行无影响。在任务切换时，处理器并不自动保存协处理器的上下文，而是会设置TS标志。这个标志会使得处理器在执行新任务指令流的任何时候遇到一条协处理器指令时产生设备不存在异常。设备不存在异常的处理程序可使用CLTS指令清除TS标志，并且保存协处理器的上下文。如果任务从没有使用过协处理器，那么相应协处理器上下文就不用保存。

        3. EM
            
            CR0的位2是仿真（EMulation）标志。当该位设置时，表示处理器没有内部或外部协处理器，执行协处理器指令时会引起设备不存在异常；当清除时，表示系统有协处理器。设置这个标志可以迫使所有浮点指令使用软件来模拟。

        4. MP
            
            CR0的位1是监控协处理器（Monitor coProcessor或Math Present）标志。用于控制WAIT/FWAIT指令与TS标志的交互作用。如果MP=1、TS=1，那么执行WAIT指令将产生一个设备不存在异常；如果MP=0，则TS标志不会影响WAIT的执行。

    2. CR0中保护控制位

        1. PE
            
            CR0的位0是启用保护（Protection Enable）标志。当设置该位时即开启了保护模式；当复位时即进入实地址模式。这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么PE和PG标志都要置位。

        2. PG
            
            CR0的位31是分页（Paging）标志。当设置该位时即开启了分页机制；当复位时则禁止分页机制，此时所有线性地址等同于物理地址。在开启这个标志之前必须已经或者同时开启PE标志。即若要启用分页机制，那么PE和PG标志都要置位。

    下表列出了通过使用PE和PG位选择的处理器工作方式。由于只有在保护方式下才可启用分页机制，所以尽管两个位分别为0和1共可以有四种组合，但只有三种组合方式有效。PE=0且PG=1是无效组合，因此，用PG为1且PE为0的值装入CR0寄存器将引起通用保护异常。需要注意的是，PG位的改变将使系统启用或禁用分页机制，因而只有当所执行的程序的代码和至少有一部分数据在线性地址空间和物理地址空间具有相同的地址的情况下，才能改变PG位。

2. CR1
    
    未定义的控制寄存器，供今后开发的处理器使用，在80386中不能使用CR1，否则会引起无效指令操作异常。

3. CR2
    
    是页故障线性地址寄存器，保存最后一次出现页故障的全32位线性地址。在报告页异常时，处理器会把引起异常的线性地址存放在CR2中。因此操作系统中的页异常处理程序可以通过检查CR2的内容来确定线性地址空间中哪一个页面引发了异常。

4. CR3：
    
    含有页目录表物理内存基地址，因此该寄存器也被称为页目录基地址寄存器PDBR。CR3用于保存页目录表的起始物理地址。由于目录是页对齐的，所以仅高20位有效，低12 位保留未用。向CR3中装入一个新值时，低12位必须为0；但从CR3中取值时，低12位被忽略。每当用MOV指令重置CR3的值时，会导致分页机制高速缓冲区的内容无效，用此方法，可以在启用分页机制之前，即把PG位置1之前，预先刷新分页机制的高速缓存。CR3寄存器即使在CR0寄存器的PG位或PE位为0时也可装入，如在实模式下也可设置CR3，以便进行分页机制的初始化。在任务切换时，CR3要被改变，但是如果新任务中CR3的值与原任务中CR3的值相同，那么处理器不刷新分页高速缓存，以便当任务共享也表时有较快的执行速度。

<h2 id="6">6 调试寄存器</h2>

调试寄存器主要作用是调试应用代码、系统代码、开发多任务操作系统.来监视代码的运行和处理器的性能。

1. DR0-DR3
    
    保留32位断点的线性地址。

2. DR4-DR5
    
    保留、未定义。

3. DR6
    
    B0—B3:断点状态的监测；BD:调试寄存器访问监测、置位,表明在指令流中,下一条指令将访问其中的一个调试寄存器；BS:单步执行标志位；BT:任务转换标志位。

4. DR7

    L0—L3:局部断点使能标志位；G0--G3: 全局断点使能标志位；LE AND GE:置位,表明处理器可以监测导致数据断点的指令，推荐置位为1；GD:通用监测使能标志位，表明是否开启调试寄存器保护；LEN0 through LEN3 : 用来表明相应断点地址寄存器内存位置的大小；R/W0 through R/W3: 相应断点的状态。

<h2 id="7">7 系统地址寄存器</h2>

全局描述符表GDT、局部描述符表LDT和中断描述符表IDT等都是保护方式下非常重要的特殊段，它们包含有为段机制所用的重要表格。为了方便快速地定位这些段，处理器采用一些特殊的寄存器保存这些段的基地址和段界限。我们把这些特殊的寄存器称为系统地址寄存器。

1. 全局描述符表寄存器GDTR
    
    GDTR长48位，其中高32位为基地址，低16位为界限。由于GDT不能有GDT本身之内的描述符进行描述定义，所以处理器采用GDTR为GDT这一特殊的系统段提供一个伪描述符。GDTR给定了GDT。GDTR中的段界限以字节为单位。由于段选择子中只有13位作为描述符索引，而每个描述符长8个字节，所以用16位的界限足够。通常，对于含有N个描述符的描述符表的段界限设为8*N-1。

2. 局部描述符表寄存器LDTR
    
    局部描述符表寄存器LDTR规定当前任务使用的局部描述符表LDT。LDTR类似于段寄存器，由程序员可见的16位的寄存器和程序员不可见的高速缓冲寄存器组成。实际上，每个任务的局部描述符表LDT作为系统的一个特殊段，由一个描述符描述。而用于描述符LDT的描述符存放在GDT中。在初始化或任务切换过程中，把描述符对应任务LDT的描述符的选择子装入LDTR，处理器根据装入LDTR可见部分的选择子，从GDT中取出对应的描述符，并把LDT的基地址、界限和属性等信息保存到LDTR的不可见的高速缓冲寄存器中。随后对LDT的访问，就可根据保存在高速缓冲寄存器中的有关信息进行合法性检查。LDTR寄存器包含当前任务的LDT的选择子。所以，装入到LDTR的选择子必须确定一个位于GDT中的类型为LDT的系统段描述符，也即选择子中的TI位必须是0，而且描述符中的类型字段所表示的类型必须为LDT。可以用一个空选择子装入LDTR，这表示当前任务没有LDT。在这种情况下，所有装入到段寄存器的选择子都必须指示GDT中的描述符，也即当前任务涉及的段均由GDT中的描述符来描述。如果再把一个TI位为1的选择子装入到段寄存器，将引起异常。

3. 中断描述符表寄存器IDTR
    
    中断描述符表寄存器IDTR指向中断描述符表IDT。IDTR长48 位，其中32位的基地址规定IDT的基地址，16位的界限规定IDT的段界限。由于80386只支持256个中断异常，所以IDT表最大长度是2K，以字节位单位的段界限为7FFH。IDTR 指示IDT的方式与GDTR指示GDT的方式相同。

4. 任务状态段寄存器TR
    
    任务状态段寄存器TR包含指示描述当前任务的任务状态段的描述符选择子，从而规定了当前任务的状态段。任务状态段的格式在后面的文章中介绍。TR也有程序员可见和不可见两部分。当把任务状态段的选择子装入到TR可见部分时，处理器自动把选择子所索引的描述符中的段基地址等信息保存到不可见的高速缓冲寄存器中。在此之后，对当前任务状态段的访问可快速方便地进行。装入到TR的选择子不能为空，必须索引位于GDT中的描述符，且描述符的类型必须是TSS。

<h2 id="8">8 其它寄存器</h2>

1. EIP
    
    主要用于存放当前代码段即将被执行的下一条指令的偏移，但其本质上并不能直接被指令直接访问。这个寄存器指令由控制转移指令、中断及异常所控制。读操作通过执行call指令并取得栈中所存放的地址来实现，而写操作则通过修改程序栈中的返回指令指针并执行RET/IRET指令来完成，因此尽管这个寄存器相当重要，但其实并不是操作系统在实现过程中所需关注的焦点。

2. TSC
    
    （时间戳寄存器）每个时钟周期时其值加1，重启时清零。通过RDTSC指令读取TSC寄存器，只有当CR4寄存器的TSD位为0时，才可以在任何优先级下执行该指令，否则只能在特权级下执行该指令。

3. 浮点寄存器
    
    由于在80486微处理器内部设有浮点运算器，因此在其内部有相应的寄存器，其中包括8个80位通用数据寄存器、1个48位指令指针寄存器、1个48位数据指针寄存器、1个16位控制字寄存器、1个16位状态字寄存器和1个16位标记字寄存器。
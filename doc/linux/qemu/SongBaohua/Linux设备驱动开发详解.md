<h1 id="0">0 目录</h1>
* [1 Linux设备驱动概述及开发环境构建](#1)
    - [1.1 设备驱动的作用](#1.1)
    - [1.2 Linux设备驱动分类](#1.2)
    - [1.3 Linux设备驱动与Linux系统的关系](#1.3)
    - [1.4 Linux设备驱动](#1.4)
    - [1.5 开发坏境的构建](#1.5)
    - [1.6 简单的LED驱动](#1.6)

---

<h1 id="1">1 Linux设备驱动概述及开发环境构建</h1>

<h2 id="1.1">1.1 设备驱动的作用</h2>

对于嵌入式开发人员来说，设备驱动这个概念并不陌生。不论是8位MCU，还是32位的单片机，我们都或多或少的写过驱动。无非就是为了让硬件能够正常工作，通过配置一些特定的寄存器，使其按照我们想要的行为进行动作。简单来说，就是`驱使硬件设备动作`。那我们为什么抛开系统，而单独讨论驱动呢？就是为了程序的模块化，用个高级点的名词就是`解耦`。这样，应用程序的开发者就不需要关心底层的硬件操作，而专注于上层应用的设计；另外，随着程序规模的日趋庞大，面对复杂的系统，驱动模块化也能够简化系统程序开发。

那么，为什么一提到linux设备驱动，大家就会有种头大的感觉呢？那还是对程序设计始终遵循的原则`高内聚，低耦合`这一思想认识不够深刻。现在，几乎所有的程序都是在这一原则下，进行开发。Linux设备驱动和普通的驱动最大的区别就是，Linux统一了驱动程序的接口，用户在面对所有的设备时，都是执行相同的操作，比如，对设备进行`open`、`write`及`read`操作；而普通的驱动程序，用户可能随意定义接口，只要与应用程序的开发者协商好就可以了。

所以说，linux设备驱动开发，就是遵循linux的一系列规范，进行驱动硬件程序的开发。是不是不难理解呢？

<h2 id="1.2">1.2 Linux设备驱动的分类</h2>

我们对事物进行分类，必然要有一个依据。那我们对linux的分类依据是什么呢？那就是访问设备的方式：串行访问，还是任意顺序访问；比较奇特的还是网络设备，因为网络设备是面向数据包的接收和发送而设计的。

所以，linux设备分为3大类：

* 字符设备，比如触摸屏、鼠标等
* 块设备，比如硬盘、eMMC等
* 网络设备

<h2 id="1.3">1.3 Linux设备驱动与Linux系统的关系</h2>

如下图所示，除网络设备外，字符设备与块设备都被映射到Linux虚拟文件系统中，通过文件系统的系统调用接口open()、write()、read()、close() 等即可访问字符设备和块设备。所有字符设备和块设备都统一呈现给用户。

Linux的块设备有两种访问方法：

* 一种是类似`dd`命令对应的原始块设备，如`/dev/sdb1`等，该命令其实就是对`write`和`Read`命令的简单封装；

* 另外一种方法是在块设备上建立FAT、EXT4、BTRFS 等文件系统，然后以文件路径如“ /home/barry/hello.txt”的形式进行
访问。在Linux 中，针对NOR、NAND 等提供了独立的内存技术设备（Memory Technology
Device，MTD）子系统，其上运行YAFFS2、JFFS2、UBIFS 等具备擦除和负载均衡能力的文
件系统。针对磁盘或者Flash 设备的FAT、EXT4、YAFFS2、JFFS2、UBIFS 等文件系统定义
了文件和目录在存储介质上的组织。而Linux 的虚拟文件系统则统一对它们进行了抽象。

![图1-1]()

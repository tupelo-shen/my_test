* [6.4 异步通知](#6.4)

<h2 id="6.4">6.4 异步通知</h2>

Although the combination of blocking and nonblocking operations and the `select` method are sufficient for querying the device most of the time, some situations aren’t efficiently managed by the techniques we’ve seen so far.

假设一个进行长计算循环的进程， 需要尽可能快地处理接收到的数据。 对于某种数据采集的外设， 一旦有数据就绪， 进程必须能够立马响应。 这当然可以调用 *`poll`* 检查数据， 但是， 更多情况下， 有更好的办法。 通过异步通知， 如果数据就绪， 发送信号给应用程序， 而不需要轮询。

User programs have to execute two steps to enable asynchronous notification from an input file. First, they specify a process as the “owner” of the file. When a process invokes the F_SETOWN command using the fcntl system call, the process ID of the owner process is saved in filp->f_owner for later use. This step is necessary for the kernel to know just whom to notify. In order to actually enable asynchronous notification, the user programs must set the FASYNC flag in the device by means of the F_SETFL fcntl command.

用户程序必须执行两个步骤才能从输入文件启用异步通知。 首先，他们将进程指定为文件的“所有者”。 当进程使用fcntl系统调用调用F_SETOWN命令时，所有者进程的进程ID将保存在filp-> f_owner中以供以后使用。 此步骤是内核知道要通知的对象所必需的。 为了实际启用异步通知，用户程序必须通过F_SETFL fcntl命令在设备中设置FASYNC标志。

使能文件的异步通知， 需要执行两步。 首先， 指定文件的所有者进程。

执行完这`2`个调用后， 输入文件可以在新数据到达时请求传送`SIGIO`信号。 该信号被发送给所属进程（或者进程组， 如果值是负的话）， 并存储在 *`filp->f_owner`*。

例如， 下面的用户程序代码为 stdin 输入文件设置了异步通知， 通知对象是当前进程：

    signal(SIGIO, &input_handler); /* dummy sample; sigaction( ) is better */
    fcntl(STDIN_FILENO, F_SETOWN, getpid( ));
    oflags = fcntl(STDIN_FILENO, F_GETFL);
    fcntl(STDIN_FILENO, F_SETFL, oflags | FASYNC);

The program named asynctest in the sources is a simple program that reads stdin as shown. It can be used to test the asynchronous capabilities of scullpipe. The program is similar to cat but doesn’t terminate on end-of-file; it responds only to input, not to the absence of input.

Note, however, that not all the devices support asynchronous notification, and you can choose not to offer it. Applications usually assume that the asynchronous capability is available only for sockets and ttys.

There is one remaining problem with input notification. When a process receives a SIGIO, it doesn’t know which input file has new input to offer. If more than one file is enabled to asynchronously notify the process of pending input, the application must still resort to poll or select to find out what happened.
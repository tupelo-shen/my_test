* [6.4 异步通知](#6.4)

<h2 id="6.4">6.4 异步通知</h2>

Although the combination of blocking and nonblocking operations and the `select` method are sufficient for querying the device most of the time, some situations aren’t efficiently managed by the techniques we’ve seen so far.

Let’s imagine a process that executes a long computational loop at low priority but needs to process incoming data as soon as possible. If this process is responding to new observations available from some sort of data acquisition peripheral, it would like to know immediately when new data is available. This application could be written to call poll regularly to check for data, but, for many situations, there is a better way. By enabling asynchronous notification, this application can receive a signal whenever data becomes available and need not concern itself with polling.

让我们假设一个进程以低优先级执行长计算循环, 但需要尽快处理传入数据。 如果此过程响应某种数据采集外设提供的新观察结果，则希望在新数据可用时立即知道。 可以定期将此应用程序写入调用轮询以检查数据，但是，对于许多情况，有一种更好的方法。 通过启用异步通知，此应用程序可以在数据可用时接收信号，并且无需关注轮询。

User programs have to execute two steps to enable asynchronous notification from an input file. First, they specify a process as the “owner” of the file. When a process invokes the F_SETOWN command using the fcntl system call, the process ID of the owner process is saved in filp->f_owner for later use. This step is necessary for the kernel to know just whom to notify. In order to actually enable asynchronous notification, the user programs must set the FASYNC flag in the device by means of the F_SETFL fcntl command.

After these two calls have been executed, the input file can request delivery of a SIGIO signal whenever new data arrives. The signal is sent to the process (or process group, if the value is negative) stored in filp->f_owner.

For example, the following lines of code in a user program enable asynchronous notification to the current process for the stdin input file:

    signal(SIGIO, &input_handler); /* dummy sample; sigaction( ) is better */
    fcntl(STDIN_FILENO, F_SETOWN, getpid( ));
    oflags = fcntl(STDIN_FILENO, F_GETFL);
    fcntl(STDIN_FILENO, F_SETFL, oflags | FASYNC);

The program named asynctest in the sources is a simple program that reads stdin as shown. It can be used to test the asynchronous capabilities of scullpipe. The program is similar to cat but doesn’t terminate on end-of-file; it responds only to input, not to the absence of input.

Note, however, that not all the devices support asynchronous notification, and you can choose not to offer it. Applications usually assume that the asynchronous capability is available only for sockets and ttys.

There is one remaining problem with input notification. When a process receives a SIGIO, it doesn’t know which input file has new input to offer. If more than one file is enabled to asynchronously notify the process of pending input, the application must still resort to poll or select to find out what happened.
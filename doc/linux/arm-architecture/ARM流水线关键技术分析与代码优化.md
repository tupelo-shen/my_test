# 1 引言

流水线技术通过多个功能部件并行工作，来缩短程序执行时间，提高处理器的效率和吞吐率，从而成为处理器设计中最为重要的技术之一。 ARM7处理器使用了典型的三级流水线的冯·诺依曼结构，ARM9系列则采用了五级流水线的哈佛结构。通过增加流水线级数简化了流水线各级的逻辑，进一步提高了处理器的性能。

ARM7的三级流水线在执行单元完成了大量的工作，包括与操作数相关的寄存器和存储器读写操作、ALU操作以及相关器件之间的数据传输。执行单元的工作往 往占用多个时钟周期，从而成为系统性能的瓶颈。ARM9采用了更为高效的五级流水线设计，增加了2个功能部件分别访问存储器并写回结果，且将读寄存器的操 作转移到译码部件上，使流水线各部件在功能上更平衡；同时其哈佛架构避免了数据访问和取指的总线冲突。

然而不论是三级流水线还是五级流水线，当出现多周期指令、跳转分支指令和中断发生的时候，流水线都会发生阻塞，而且相邻指令之间也可能因为寄存器冲突导致 流水线阻塞， 降低流水线的效率。 本文在对流水线原理及运行情况详细分析的基础上， 研究通过调整指令执行序列来提高流水线运行性能的方法。

# 2 ARM7/ARM9流水线技术

## 2.1 ARM7流水线技术 

ARM7系列处理器中每条指令分取指、译码、执行三个阶段，分别在不同的功能部件上依次独立完成。取指部件完成从存储器装载一条指令，通过译码部件产生下一周期数据路径需要的控制信号，完成寄存器的解码，再送到执行单元完成寄存器的读取、ALU运算及运算结果的写回，需要访问存储器的指令完成存储器的访问。流水线上虽然一条指令仍需3个时钟周期来完成，但通过多个部件并行，使得处理器的吞吐率约为每个周期一条指令，提高了流式指令的处理速度，从而可达到0.9 MIPS/MHz的指令执行速度。

![Picture!](https://raw.githubusercontent.com/tupelo-shen/my_test/master/doc/linux/arm-architecture/ARM7%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF.PNG)

在三级流水线下，通过R15访问PC(程序计数器)时会出现取指位置和执行位置不同的现象。这须结合流水线的执行情况考虑，取指部件根据PC取指，取指完 成后PC+4送到PC，并把取到的指令传递给译码部件，然后取指部件根据新的PC取指。因为每条指令4字节，故PC值等于当前程序执行位置+8。

## 2.2 ARM9流水线技术

ARM9系列处理器的流水线分为取指、译码、执行、访存、回写。取指部件完成从指令存储器取指；译码部件读取寄存器操作数，与三级流水线中不占有数据路径 区别很大；执行部件产生ALU运算结果或产生存储器地址(对于存储器访问指令来讲)；访存部件访问数据存储器；回写部件完成执行结果写回寄存器。把三级流 水线中的执行单元进一步细化，减少了在每个时钟周期内必须完成的工作量，进而允许使用较高的时钟频率，且具有分开的指令和数据存储器，减少了冲突的发生， 每条指令的平均周期数明显减少。

![Picture!](https://raw.githubusercontent.com/tupelo-shen/my_test/master/doc/linux/arm-architecture/ARM9%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF.PNG)

STMFD SP！，{R0-R7，LR}

对于这条指令伪代码的解释，大体是这样的：

SP = SP-9×4;                    // SP的指针始终指向栈顶的位置
address = SP;                   // 从栈顶开始存放
for i = 0 to 7                  
    Memory[address] = Ri;       // 循环把R0-R7保存在栈中  
    address  = address + 4;     // 地址+4
Memory[address] = LR;           // 把LR寄存器的内容保存到栈中

LDMFD SP！，{R0-R7，PC}^
对于这条指令伪代码的解释，大体是这样的：

address = SP;
for i = 0 to 7
    Ri = Memory[address ,4]
    address = address + 4;
SP = address;
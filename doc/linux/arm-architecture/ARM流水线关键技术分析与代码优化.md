# 1 引言

流水线技术通过多个功能部件并行工作，来缩短程序执行时间，提高处理器的效率和吞吐率，从而成为处理器设计中最为重要的技术之一。 ARM7处理器使用了典型的三级流水线的冯·诺依曼结构，ARM9系列则采用了五级流水线的哈佛结构。通过增加流水线级数简化了流水线各级的逻辑，进一步提高了处理器的性能。

ARM7的三级流水线在执行单元完成了大量的工作，包括与操作数相关的寄存器和存储器读写操作、ALU操作以及相关器件之间的数据传输。执行单元的工作往 往占用多个时钟周期，从而成为系统性能的瓶颈。ARM9采用了更为高效的五级流水线设计，增加了2个功能部件分别访问存储器并写回结果，且将读寄存器的操 作转移到译码部件上，使流水线各部件在功能上更平衡；同时其哈佛架构避免了数据访问和取指的总线冲突。

然而不论是三级流水线还是五级流水线，当出现多周期指令、跳转分支指令和中断发生的时候，流水线都会发生阻塞，而且相邻指令之间也可能因为寄存器冲突导致 流水线阻塞， 降低流水线的效率。 本文在对流水线原理及运行情况详细分析的基础上， 研究通过调整指令执行序列来提高流水线运行性能的方法。

# 2 ARM7/ARM9流水线技术

## 2.1 ARM7流水线技术 

ARM7系列处理器中每条指令分取指、译码、执行三个阶段，分别在不同的功能部件上依次独立完成。取指部件完成从存储器装载一条指令，通过译码部件产生下一周期数据路径需要的控制信号，完成寄存器的解码，再送到执行单元完成寄存器的读取、ALU运算及运算结果的写回，需要访问存储器的指令完成存储器的访问。流水线上虽然一条指令仍需3个时钟周期来完成，但通过多个部件并行，使得处理器的吞吐率约为每个周期一条指令，提高了流式指令的处理速度，从而可达到0.9 MIPS/MHz的指令执行速度。

![Picture!](https://raw.githubusercontent.com/tupelo-shen/my_test/master/doc/linux/arm-architecture/ARM7%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF.PNG)

在三级流水线下，通过R15访问PC(程序计数器)时会出现取指位置和执行位置不同的现象。这须结合流水线的执行情况考虑，取指部件根据PC取指，取指完 成后PC+4送到PC，并把取到的指令传递给译码部件，然后取指部件根据新的PC取指。因为每条指令4字节，故PC值等于当前程序执行位置+8。

## 2.2 ARM9流水线技术

ARM9系列处理器的流水线分为取指、译码、执行、访存、回写。取指部件完成从指令存储器取指；译码部件读取寄存器操作数，与三级流水线中不占有数据路径 区别很大；执行部件产生ALU运算结果或产生存储器地址(对于存储器访问指令来讲)；访存部件访问数据存储器；回写部件完成执行结果写回寄存器。把三级流 水线中的执行单元进一步细化，减少了在每个时钟周期内必须完成的工作量，进而允许使用较高的时钟频率，且具有分开的指令和数据存储器，减少了冲突的发生， 每条指令的平均周期数明显减少。


#3 三级流水线运行情况分析

从上面的图中可以看出，三级流水线在处理简单的寄存器指令时，平均每个时钟周期一条指令；但是存在存储器访问指令、跳转指令的情况下会出现流水线阻断的情况，导致流水线的性能下降。上图1给出了流水线的最佳运行情况，图中的MOV、ADD、SUB指令为单周期指令。从T1开始，用三个时钟周期执行了3条指令。

流水线的阻断现象是影响性能的主要因素，那么我们就可能出现的阻断情况进行分析：

#3.1 带有存储器访问指令的流水线

存储器访问指令LDR就是多周期指令，如图3所示。

![Picture!](https://raw.githubusercontent.com/tupelo-shen/my_test/master/doc/linux/arm-architecture/ARM7%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF.PNG)

从图中可以看出，LDR指令的执行分为3步：

1. 算地址（占用信号控制线）
2. 访存（访问存储器，占用执行单元）
3. 回写（占用执行单元）

所以，在正常执行完LDR指令后，执行第一个SUB指令，由于译码也要占用信号控制线，所以译码被阻断。而访存和回写寄存器的过程中需要继续占用执行单元，所以下一条（第一个SUB）的执行也被阻断。由于采用的是冯·诺依曼结构，所以不能同时访问数据存储器和指令存储器，所以当LDR处于访存的周期中时，MOV指令的取指被阻断。因此，处理器的8个时钟周期执行了6条指令，指令平均周期数（CPI）为1.3周期。

# 3.2 带有分支指令的流水线

当指令序列中含有具有分支功能的指令(如 *BL* 等)时，流水线也会被阻断，如图-4所示。分支指令在执行时，其后第1条指令被译码，其后第2条指令进行取指，但 是这两步操作的指令并不被执行。因为分支指令执行完毕后，程序应该转到跳转的目标地址处执行，因此在流水线上需要丢弃这两条指令，同时程序计数器就会转移 到新的位置接着进行取指、译码和执行。此外还有一些特殊的转移指令需要在跳转完成的同时进行写链接寄存器、程序计数寄存器，如BL执行过程中包括两个附加 操作——写链接寄存器和调整程序指针。这两个操作仍然占用执行单元，这时处于译码和取指的流水线被阻断了。

![Picture!](https://raw.githubusercontent.com/tupelo-shen/my_test/master/doc/linux/arm-architecture/%E5%B8%A6%E6%9C%89%E5%88%86%E6%94%AF%E6%8C%87%E4%BB%A4%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF.PNG)

# 3.3 中断流水线

处理器中断的发生具有不确定性，与当前所执行的指令没有任何关系。在中断发生时，处理器总是会执行完当前正被执行的指令，然后去响应中断。如图5所示，在 *Ox90000*处的指令ADD执行期间IRQ中断发生，这时要等待ADD指令执行完毕，IRQ才获得执行单元，处理器开始处理IRQ中断，保存程序返回地 址并调整程序指针指向Oxl8内存单元。在Oxl8处有IRO中断向量(也就是跳向IRQ中断服务的指令)，接下来执行跳转指令转向中断服务程序，流水线 又被阻断，执行0x18处指令的过程同带有分支指令的流水线。

![Picture!](https://raw.githubusercontent.com/tupelo-shen/my_test/master/doc/linux/arm-architecture/%E4%B8%AD%E6%96%AD%E6%B5%81%E6%B0%B4%E7%BA%BF.PNG)

#4 五级流水线

五级流水线技术在多种RISC处理器中被广泛使用，被认为是经典的处理器设计方式。五级流水线中的存储器访问部件(访存)和寄存器回写部件，解决了三级流水线中存储器访问指令在指令执行阶段的延迟问题。图5为五级流水线的运行情况(五级流水线也存在阻断)。

#4.1 五级流水线互锁分析

五级流水线只存在一种互锁，即寄存器冲突。读寄存器是在译码阶段，写寄存器是在回写阶段。如果当前指令(A)的目的操作数寄存器和下一条指令(B)的源操 作数寄存器一致，B指令就需要等A回写之后才能译码。这就是五级流水线中的寄存器冲突。如图6所示，LDR指令写R9是在回写阶段，而MOV中需要用到的 R9正是LDR在回写阶段将会重新写入的寄存器值，MOV译码需要等待，直到LDR指令的寄存器回写操作完成。(注：现在处理器设计中，可以通过寄存器旁 路技术对流水线进行优化，解决流水线的寄存器冲突问题。)

![Picture!](https://raw.githubusercontent.com/tupelo-shen/my_test/master/doc/linux/arm-architecture/%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E4%BA%92%E9%94%81.PNG)

虽然流水线互锁会增加代码执行时间，但是为初期的设计者提供了巨大的方便，可以不必考虑使用的寄存器会不会造成冲突；而且编译器以及汇编程序员可以通过重新设计代码的顺序或者其他方法来减少互锁的数量。另外分支指令和中断的发生仍然会阻断五级流水线。

# 4.2 五级流水线优化

采用重新设计代码顺序在很多情况下可以很好地减少流水线的阻塞，使流水线的运行流畅。下面详细分析代码优化对流水线的优化和效率的提高。
要实现把内存地址0x1000和Ox2000处的数据分别拷贝到0x8000和0x9000处。

1. Oxl000处的内容：1，2，3，4，5，6，7，8，9，10
2. Ox2000处的内容：H，e，l，l，o，W，o，r，l，d

实现第一个拷贝过程的程序代码及指令的执行时空图如图7所示。

![Picture!](https://raw.githubusercontent.com/tupelo-shen/my_test/master/doc/linux/arm-architecture/%E6%9C%AA%E7%BB%8F%E4%BC%98%E5%8C%96%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF.PNG)

全部拷贝过程由两个结构相同的循环各自独立完成，分别实现两块数据的拷贝，并且两个拷贝过程极为类似，分析其中一个即可。

T1～T3是3个单独的时钟周期；T4～T11是一个循环，在时空图中描述了第一次循环的执行情况。在T12的时候写LR的同时，开始对循环的第一条语句进行取指，所以总的流水线周期数为3+10×10+2×9=121。整个拷贝过程需要121×2+2=244个时钟周期完成。

考虑到通过减少流水线的冲突可以提高流水线的执行效率，而流水线的冲突主要来自寄存器冲突和分支指令，因此对代码作如下两方面调整：

1. 将两个循环合并成一个循环能够充分减少循环跳转的次数，减少跳转带来的流水线停滞；
2. 调整代码的顺序，将带有与临近指令不相关的寄存器插到带有相关寄存器的指令之间，能够充分地避免寄存器冲突导致的流水线阻塞。

对代码调整和流水线的时空图如图8所示。

![Picture!](https://raw.githubusercontent.com/tupelo-shen/my_test/master/doc/linux/arm-architecture/%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF.PNG)

调整之后，T1～T5是5个单独的时钟周期，T6～T13是一个循环，同样在T14的时候BNE指令在写LR的同时，循环的第一条指令开始取指，所以总的指令周期数为5+10×10+2×9+2=125。

通过两段代码的比较可看出：调整之前整个拷贝过程总共使用了244个时钟周期，调整了循环内指令的顺序后，总共使用了125个时钟周期就完成了同样的工作，时钟周期减少了119个，缩短了119／244=48．8％，效率提升十分明显。

代码优化前后执行周期数对比的情况如表1所列。

|  | 优化前周期数 | 优化后周期数 | 提高比例-% |
|--|-------------|--------------|---------|
|顺序语句| 6    | 5  | 16.7 |
| 循环1  | 118  | 60 | 49.2 |
| 循环2  | 120  | 60 | 50 | 
| 总周期数  | 224  | 125 | 48.8 |

因此流水线的优化问题主要应从两方面考虑：

1. 通过合并循环等方式减少分支指令的个数，从而减少流水线的浪费；
2. 通过交换指令的顺序，避免寄存器冲突造成的流水线停滞。


# 5 结论

流水线技术提高了处理器的并行性，与串行CPU相比大大提高了处理器性能。通过调节指令序列的方法又能够有效地避免流水线冲突的发生，从而提高了流水线的执行效率。因此如何采用智能算法进行指令序列的自动调节以提高流水线的效率和进一步提高处理器的并行性将是以后研究的主要方向。

